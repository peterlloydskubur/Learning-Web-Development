{
    var _ns_ = {
            id: 'wisp.expander',
            doc: 'wisp syntax and macro expander module'
        };
    var wisp_ast = require('./ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var isQuote = wisp_ast.isQuote;
    var symbol = wisp_ast.symbol;
    var namespace = wisp_ast.namespace;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var conj = wisp_sequence.conj;
    var partition = wisp_sequence.partition;
    var seq = wisp_sequence.seq;
    var repeatedly = wisp_sequence.repeatedly;
    var isEmpty = wisp_sequence.isEmpty;
    var map = wisp_sequence.map;
    var mapv = wisp_sequence.mapv;
    var vec = wisp_sequence.vec;
    var set = wisp_sequence.set;
    var isEvery = wisp_sequence.isEvery;
    var concat = wisp_sequence.concat;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var last = wisp_sequence.last;
    var mapcat = wisp_sequence.mapcat;
    var nth = wisp_sequence.nth;
    var butlast = wisp_sequence.butlast;
    var interleave = wisp_sequence.interleave;
    var cons = wisp_sequence.cons;
    var count = wisp_sequence.count;
    var take = wisp_sequence.take;
    var dissoc = wisp_sequence.dissoc;
    var some = wisp_sequence.some;
    var assoc = wisp_sequence.assoc;
    var reduce = wisp_sequence.reduce;
    var filter = wisp_sequence.filter;
    var isSeq = wisp_sequence.isSeq;
    var zipmap = wisp_sequence.zipmap;
    var drop = wisp_sequence.drop;
    var lazySeq = wisp_sequence.lazySeq;
    var range = wisp_sequence.range;
    var reverse = wisp_sequence.reverse;
    var dorun = wisp_sequence.dorun;
    var mapIndexed = wisp_sequence.mapIndexed;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isDictionary = wisp_runtime.isDictionary;
    var isVector = wisp_runtime.isVector;
    var keys = wisp_runtime.keys;
    var get = wisp_runtime.get;
    var vals = wisp_runtime.vals;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isEven = wisp_runtime.isEven;
    var isOdd = wisp_runtime.isOdd;
    var isEqual = wisp_runtime.isEqual;
    var max = wisp_runtime.max;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var dictionary = wisp_runtime.dictionary;
    var merge = wisp_runtime.merge;
    var subs = wisp_runtime.subs;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var capitalize = wisp_string.capitalize;
}
var __macros__ = exports.__macros__ = {};
var expand = function expand(expander, form, env) {
    return function () {
        var metadataø1 = meta(form) || {};
        var parmasø1 = rest(form);
        var implicitø1 = map(function ($1) {
                return isEqual('&form', $1) ? form : isEqual('&env', $1) ? env : 'else' ? $1 : void 0;
            }, (meta(expander) || 0)['implicit'] || []);
        var paramsø1 = vec(concat(implicitø1, vec(rest(form))));
        var expansionø1 = expander.apply(void 0, paramsø1);
        return expansionø1 ? withMeta(expansionø1, conj(metadataø1, meta(expansionø1))) : expansionø1;
    }.call(this);
};
var installMacro = exports.installMacro = function installMacro(op, expander) {
        return (__macros__ || 0)[name(op)] = expander;
    };
var macro = function macro(op) {
    return isSymbol(op) && (__macros__ || 0)[name(op)];
};
var isDotSyntax = exports.isDotSyntax = function isDotSyntax(op) {
        return isSymbol(op) && '.' === name(op);
    };
var isMethodSyntax = exports.isMethodSyntax = function isMethodSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === first(idø1) && !('-' === second(idø1)) && !('.' === idø1);
        }.call(this);
    };
var isFieldSyntax = exports.isFieldSyntax = function isFieldSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === first(idø1) && '-' === second(idø1);
        }.call(this);
    };
var isNewSyntax = exports.isNewSyntax = function isNewSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === last(idø1) && !('.' === idø1);
        }.call(this);
    };
var methodSyntax = exports.methodSyntax = function methodSyntax(op, target) {
        var params = Array.prototype.slice.call(arguments, 2);
        return function () {
            var opMetaø1 = meta(op);
            var formStartø1 = (opMetaø1 || 0)['start'];
            var targetMetaø1 = meta(target);
            var memberø1 = withMeta(symbol(subs(name(op), 1)), conj(opMetaø1, {
                    'start': {
                        'line': (formStartø1 || 0)['line'],
                        'column': inc((formStartø1 || 0)['column'])
                    }
                }));
            var agetø1 = withMeta(symbol(void 0, 'aget'), conj(opMetaø1, {
                    'end': {
                        'line': (formStartø1 || 0)['line'],
                        'column': inc((formStartø1 || 0)['column'])
                    }
                }));
            var methodø1 = withMeta(list.apply(void 0, [agetø1].concat([target], [list.apply(void 0, [symbol(void 0, 'quote')].concat([memberø1]))])), conj(opMetaø1, { 'end': (meta(target) || 0)['end'] }));
            return isNil(target) ? (function () {
                throw Error('Malformed method expression, expecting (.method object ...)');
            })() : list.apply(void 0, [methodø1].concat(vec(params)));
        }.call(this);
    };
var fieldSyntax = exports.fieldSyntax = function fieldSyntax(field, target) {
        var more = Array.prototype.slice.call(arguments, 2);
        return function () {
            var metadataø1 = meta(field);
            var startø1 = (metadataø1 || 0)['start'];
            var endø1 = (metadataø1 || 0)['end'];
            var memberø1 = withMeta(symbol(subs(name(field), 2)), conj(metadataø1, {
                    'start': {
                        'line': (startø1 || 0)['line'],
                        'column': (startø1 || 0)['column'] + 2
                    }
                }));
            return isNil(target) || count(more) ? (function () {
                throw Error('Malformed member expression, expecting (.-member target)');
            })() : list.apply(void 0, [symbol(void 0, 'aget')].concat([target], [list.apply(void 0, [symbol(void 0, 'quote')].concat([memberø1]))]));
        }.call(this);
    };
var dotSyntax = exports.dotSyntax = function dotSyntax(op, target, field) {
        var params = Array.prototype.slice.call(arguments, 3);
        !isSymbol(field) ? (function () {
            throw Error('Malformed . form');
        })() : void 0;
        return function () {
            var _fieldø1 = name(field);
            return ('-' === first(_fieldø1) ? fieldSyntax : methodSyntax).apply(void 0, [
                symbol('' + '.' + _fieldø1),
                target
            ].concat(params));
        }.call(this);
    };
var newSyntax = exports.newSyntax = function newSyntax(op) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var idø1 = name(op);
            var idMetaø1 = (idø1 || 0)['meta'];
            var renameø1 = subs(idø1, 0, dec(count(idø1)));
            var constructorø1 = withMeta(symbol(renameø1), conj(idMetaø1, {
                    'end': {
                        'line': ((idMetaø1 || 0)['end'] || 0)['line'],
                        'column': dec(((idMetaø1 || 0)['end'] || 0)['column'])
                    }
                }));
            var operatorø1 = withMeta(symbol(void 0, 'new'), conj(idMetaø1, {
                    'start': {
                        'line': ((idMetaø1 || 0)['end'] || 0)['line'],
                        'column': dec(((idMetaø1 || 0)['end'] || 0)['column'])
                    }
                }));
            return list.apply(void 0, [symbol(void 0, 'new')].concat([constructorø1], vec(params)));
        }.call(this);
    };
var keywordInvoke = exports.keywordInvoke = function keywordInvoke() {
        switch (arguments.length) {
        case 2:
            var keyword = arguments[0];
            var target = arguments[1];
            return list.apply(void 0, [symbol(void 0, 'get')].concat([target], [keyword]));
        case 3:
            var keyword = arguments[0];
            var target = arguments[1];
            var default_ = arguments[2];
            return list.apply(void 0, [symbol(void 0, 'get')].concat([target], [keyword], [default_]));
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var desugar = function desugar(expander, form) {
    return function () {
        var desugaredø1 = expander.apply(void 0, vec(form));
        var metadataø1 = conj({}, meta(form), meta(desugaredø1));
        return withMeta(desugaredø1, metadataø1);
    }.call(this);
};
var macroexpand1 = exports.macroexpand1 = function macroexpand1(form, env) {
        return function () {
            var opø1 = isList(form) && first(form);
            var expanderø1 = macro(opø1);
            return expanderø1 ? expand(expanderø1, form, env) : isKeyword(opø1) ? desugar(keywordInvoke, form) : isDotSyntax(opø1) ? desugar(dotSyntax, form) : isFieldSyntax(opø1) ? desugar(fieldSyntax, form) : isMethodSyntax(opø1) ? desugar(methodSyntax, form) : isNewSyntax(opø1) ? desugar(newSyntax, form) : 'else' ? form : void 0;
        }.call(this);
    };
var macroexpand = exports.macroexpand = function macroexpand(form, env) {
        return function loop() {
            var recur = loop;
            var originalø1 = form;
            var expandedø1 = macroexpand1(form, env);
            do {
                recur = originalø1 === expandedø1 ? originalø1 : (loop[0] = expandedø1, loop[1] = macroexpand1(expandedø1, env), loop);
            } while (originalø1 = loop[0], expandedø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var syntaxQuote = exports.syntaxQuote = function syntaxQuote(form) {
        return isSymbol(form) ? list(symbol(void 0, 'quote'), form) : isKeyword(form) ? list(symbol(void 0, 'quote'), form) : isNumber(form) || isString(form) || isBoolean(form) || isNil(form) || isRePattern(form) ? form : isUnquote(form) ? second(form) : isUnquoteSplicing(form) ? readerError('Illegal use of `~@` expression, can only be present in a list') : isEmpty(form) ? form : isDictionary(form) ? list(symbol(void 0, 'apply'), symbol(void 0, 'dictionary'), cons(symbol(void 0, '.concat'), sequenceExpand(concat.apply(void 0, seq(form))))) : isVector(form) ? cons(symbol(void 0, '.concat'), sequenceExpand(form)) : isList(form) ? isEmpty(form) ? cons(symbol(void 0, 'list'), void 0) : list(symbol(void 0, 'apply'), symbol(void 0, 'list'), cons(symbol(void 0, '.concat'), sequenceExpand(form))) : 'else' ? readerError('Unknown Collection type') : void 0;
    };
var syntaxQuoteExpand = exports.syntaxQuoteExpand = syntaxQuote;
var unquoteSplicingExpand = exports.unquoteSplicingExpand = function unquoteSplicingExpand(form) {
        return isVector(form) ? form : list(symbol(void 0, 'vec'), form);
    };
var sequenceExpand = exports.sequenceExpand = function sequenceExpand(forms) {
        return map(function (form) {
            return isUnquote(form) ? [second(form)] : isUnquoteSplicing(form) ? unquoteSplicingExpand(second(form)) : 'else' ? [syntaxQuoteExpand(form)] : void 0;
        }, forms);
    };
installMacro('syntax-quote', syntaxQuoteExpand);
var expandNotEqual = exports.expandNotEqual = function expandNotEqual() {
        var body = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, 'not')].concat([list.apply(void 0, [symbol(void 0, '=')].concat(vec(body)))]));
    };
installMacro('not=', expandNotEqual);
var expandIfNot = exports.expandIfNot = function expandIfNot(condition, truthy, alternative) {
        return list.apply(void 0, [symbol(void 0, 'if')].concat([list.apply(void 0, [symbol(void 0, 'not')].concat([condition]))], [truthy], [alternative]));
    };
installMacro('if-not', expandIfNot);
var expandComment = exports.expandComment = function expandComment() {
        var body = Array.prototype.slice.call(arguments, 0);
        return void 0;
    };
installMacro('comment', expandComment);
var expandThreadFirst = exports.expandThreadFirst = function expandThreadFirst() {
        var operations = Array.prototype.slice.call(arguments, 0);
        return reduce(function (form, operation) {
            return cons(first(operation), cons(form, rest(operation)));
        }, first(operations), map(function ($1) {
            return isList($1) ? $1 : list.apply(void 0, [$1].concat());
        }, rest(operations)));
    };
installMacro('->', expandThreadFirst);
var expandThreadLast = exports.expandThreadLast = function expandThreadLast() {
        var operations = Array.prototype.slice.call(arguments, 0);
        return reduce(function (form, operation) {
            return concat(operation, [form]);
        }, first(operations), map(function ($1) {
            return isList($1) ? $1 : list.apply(void 0, [$1].concat());
        }, rest(operations)));
    };
installMacro('->>', expandThreadLast);
var expandDots = exports.expandDots = function expandDots(x) {
        var forms = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, '->')].concat([x], vec(map(function ($1) {
            return isList($1) ? cons(symbol(void 0, '.'), $1) : list(symbol(void 0, '.'), $1);
        }, forms))));
    };
installMacro('..', expandDots);
var expandThreadAs = exports.expandThreadAs = function expandThreadAs(expr, name) {
        var forms = Array.prototype.slice.call(arguments, 2);
        return list.apply(void 0, [symbol(void 0, 'let')].concat([[name].concat([expr], vec(mapcat(function (form) {
                return [
                    name,
                    form
                ];
            }, forms)))], [name]));
    };
installMacro('as->', expandThreadAs);
var expandCond = exports.expandCond = function expandCond() {
        var clauses = Array.prototype.slice.call(arguments, 0);
        return !isEmpty(clauses) ? list(symbol(void 0, 'if'), first(clauses), isEmpty(rest(clauses)) ? (function () {
            throw Error('cond requires an even number of forms');
        })() : second(clauses), cons(symbol(void 0, 'cond'), rest(rest(clauses)))) : void 0;
    };
installMacro('cond', expandCond);
var expandCase = exports.expandCase = function expandCase(e) {
        var clauses = Array.prototype.slice.call(arguments, 1);
        return function () {
            var symø1 = isSymbol(e) ? e : gensym('case-binding');
            var pairsø1 = partition(2, clauses);
            var eq_ø1 = function (c) {
                return list.apply(void 0, [symbol(void 0, '=')].concat([symø1], [list.apply(void 0, [symbol(void 0, 'quote')].concat([c]))]));
            };
            var tailø1 = isOdd(count(clauses)) ? last(clauses) : list.apply(void 0, [symbol(void 0, 'throw')].concat([list.apply(void 0, [symbol(void 0, 'Error')].concat([list.apply(void 0, [symbol(void 0, 'str')].concat(['No matching clause: '], [symø1]))]))]));
            return function loop() {
                var recur = loop;
                var pairsø2 = pairsø1;
                var condsø1 = [];
                do {
                    recur = isEmpty(pairsø2) ? function () {
                        var resultø1 = list.apply(void 0, [symbol(void 0, 'cond')].concat(vec(condsø1), ['\uA789else'], [tailø1]));
                        return isEqual(e, symø1) ? resultø1 : list.apply(void 0, [symbol(void 0, 'let')].concat([[symø1].concat([e])], [resultø1]));
                    }.call(this) : function () {
                        var xø1 = first(pairsø2);
                        var xsø1 = rest(pairsø2);
                        var constsø1 = first(xø1);
                        var resø1 = second(xø1);
                        return loop[0] = xsø1, loop[1] = conj(condsø1, !isList(constsø1) ? eq_ø1(constsø1) : list.apply(void 0, [symbol(void 0, 'or')].concat(vec(map(eq_ø1, constsø1)))), resø1), loop;
                    }.call(this);
                } while (pairsø2 = loop[0], condsø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
installMacro('case', expandCase);
var expandCondp = exports.expandCondp = function expandCondp(pred, expr) {
        var clauses = Array.prototype.slice.call(arguments, 2);
        return function () {
            var sym_ø1 = gensym('condp-binding');
            var symø1 = isSymbol(expr) ? expr : sym_ø1;
            var compareø1 = function (x) {
                return list.apply(void 0, [pred].concat([x], [symø1]));
            };
            var splitsø1 = function splits(xs) {
                return isEmpty(xs) ? list.apply(void 0, [symbol(void 0, 'throw')].concat([list.apply(void 0, [symbol(void 0, 'Error')].concat([list.apply(void 0, [symbol(void 0, 'str')].concat(['No matching clause: '], [symø1]))]))])) : isEqual(1, count(xs)) ? first(xs) : isEqual('\uA789>>', second(xs)) ? list.apply(void 0, [symbol(void 0, 'if-let')].concat([[sym_ø1].concat([compareø1(first(xs))])], [list.apply(void 0, [third(xs)].concat([sym_ø1]))], [splits(drop(3, xs))])) : 'else' ? list.apply(void 0, [symbol(void 0, 'if')].concat([compareø1(first(xs))], [second(xs)], [splits(drop(2, xs))])) : void 0;
            };
            return isEqual(symø1, expr) ? splitsø1(clauses) : list.apply(void 0, [symbol(void 0, 'let')].concat([[symø1].concat([expr])], [splitsø1(clauses)]));
        }.call(this);
    };
installMacro('condp', expandCondp);
var _thread = function _thread(insert, sym, test, form) {
    return function () {
        var formø2 = isList(form) ? form : list(form);
        return list.apply(void 0, [symbol(void 0, 'if')].concat([test], [sym], [insert(sym, formø2)]));
    }.call(this);
};
var _condThread = function _condThread(expr, clauses, insert) {
    return function () {
        var symø1 = gensym('cond-thread-binding');
        return list.apply(void 0, [symbol(void 0, 'as->')].concat([expr], [symø1], vec(map(function ($1) {
            return _thread(insert, symø1, list.apply(void 0, [symbol(void 0, 'not')].concat([first($1)])), second($1));
        }, partition(2, clauses)))));
    }.call(this);
};
var expandCondThreadFirst = exports.expandCondThreadFirst = function expandCondThreadFirst(expr) {
        var clauses = Array.prototype.slice.call(arguments, 1);
        return _condThread(expr, clauses, function (sym, form) {
            return list.apply(void 0, [
                first(form),
                sym
            ].concat(vec(rest(form))));
        });
    };
installMacro('cond->', expandCondThreadFirst);
var expandCondThreadLast = exports.expandCondThreadLast = function expandCondThreadLast(expr) {
        var clauses = Array.prototype.slice.call(arguments, 1);
        return _condThread(expr, clauses, function (sym, form) {
            return list.apply(void 0, vec(concat(form, [sym])));
        });
    };
installMacro('cond->>', expandCondThreadLast);
var _someThread = function _someThread(expr, forms, insert) {
    return function () {
        var symø1 = gensym('some-thread-binding');
        return list.apply(void 0, [symbol(void 0, 'as->')].concat([expr], [symø1], vec(map(function ($1) {
            return _thread(insert, symø1, list.apply(void 0, [symbol(void 0, 'nil?')].concat([symø1])), $1);
        }, forms))));
    }.call(this);
};
var expandSomeThreadFirst = exports.expandSomeThreadFirst = function expandSomeThreadFirst(expr) {
        var forms = Array.prototype.slice.call(arguments, 1);
        return _someThread(expr, forms, function (sym, form) {
            return list.apply(void 0, [
                first(form),
                sym
            ].concat(vec(rest(form))));
        });
    };
installMacro('some->', expandSomeThreadFirst);
var expandSomeThreadLast = exports.expandSomeThreadLast = function expandSomeThreadLast(expr) {
        var forms = Array.prototype.slice.call(arguments, 1);
        return _someThread(expr, forms, function (sym, form) {
            return list.apply(void 0, vec(concat(form, [sym])));
        });
    };
installMacro('some->>', expandSomeThreadLast);
var expandDefn = exports.expandDefn = function expandDefn(_andForm, name) {
        var docPlusMetaPlusBody = Array.prototype.slice.call(arguments, 2);
        return function () {
            var docø1 = isString(first(docPlusMetaPlusBody)) ? first(docPlusMetaPlusBody) : void 0;
            var metaPlusBodyø1 = docø1 ? rest(docPlusMetaPlusBody) : docPlusMetaPlusBody;
            var metadataø1 = isDictionary(first(metaPlusBodyø1)) ? conj({ 'doc': docø1 }, first(metaPlusBodyø1)) : void 0;
            var bodyø1 = metadataø1 ? rest(metaPlusBodyø1) : metaPlusBodyø1;
            var idø1 = withMeta(name, conj(meta(name) || {}, metadataø1));
            var fnø1 = withMeta(list.apply(void 0, [symbol(void 0, 'fn')].concat([idø1], vec(bodyø1))), meta(_andForm));
            return list.apply(void 0, [symbol(void 0, 'def')].concat([idø1], [fnø1]));
        }.call(this);
    };
installMacro('defn', withMeta(expandDefn, { 'implicit': ['&form'] }));
var expandPrivateDefn = exports.expandPrivateDefn = function expandPrivateDefn(name) {
        var body = Array.prototype.slice.call(arguments, 1);
        return function () {
            var metadataø1 = conj(meta(name) || {}, { 'private': true });
            var idø1 = withMeta(name, metadataø1);
            return list.apply(void 0, [symbol(void 0, 'defn')].concat([idø1], vec(body)));
        }.call(this);
    };
installMacro('defn-', expandPrivateDefn);
var expandLazySeq = exports.expandLazySeq = function expandLazySeq() {
        var body = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, '.call')].concat([symbol(void 0, 'lazy-seq')], [void 0], [false], [list.apply(void 0, [symbol(void 0, 'fn')].concat([[]], vec(body)))]));
    };
installMacro('lazy-seq', expandLazySeq);
var expandWhen = exports.expandWhen = function expandWhen(test) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'if')].concat([test], [list.apply(void 0, [symbol(void 0, 'do')].concat(vec(body)))]));
    };
installMacro('when', expandWhen);
var expandWhenNot = exports.expandWhenNot = function expandWhenNot(test) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'when')].concat([list.apply(void 0, [symbol(void 0, 'not')].concat([test]))], vec(body)));
    };
installMacro('when-not', expandWhenNot);
var expandIfLet = exports.expandIfLet = function expandIfLet(bindings, then, else_) {
        return function () {
            var nameø1 = first(bindings);
            var testø1 = second(bindings);
            var symø1 = gensym('if-let-binding');
            return list.apply(void 0, [symbol(void 0, 'let')].concat([[symø1].concat([testø1])], [list.apply(void 0, [symbol(void 0, 'if')].concat([symø1], [list.apply(void 0, [symbol(void 0, 'let')].concat([[nameø1].concat([symø1])], [then]))], [else_]))]));
        }.call(this);
    };
installMacro('if-let', expandIfLet);
var expandWhenLet = exports.expandWhenLet = function expandWhenLet(bindings) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'if-let')].concat([bindings], [list.apply(void 0, [symbol(void 0, 'do')].concat(vec(body)))]));
    };
installMacro('when-let', expandWhenLet);
var expandIfSome = exports.expandIfSome = function expandIfSome(bindings, then, else_) {
        return function () {
            var nameø1 = first(bindings);
            var testø1 = second(bindings);
            var symø1 = isSymbol(nameø1) ? nameø1 : gensym('if-some-binding');
            return list.apply(void 0, [symbol(void 0, 'let')].concat([[symø1].concat([testø1])], [list.apply(void 0, [symbol(void 0, 'if-not')].concat([list.apply(void 0, [symbol(void 0, 'nil?')].concat([symø1]))], [list.apply(void 0, [symbol(void 0, 'let')].concat([[nameø1].concat([symø1])], [then]))], [else_]))]));
        }.call(this);
    };
installMacro('if-some', expandIfSome);
var expandWhenSome = exports.expandWhenSome = function expandWhenSome(bindings) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'if-some')].concat([bindings], [list.apply(void 0, [symbol(void 0, 'do')].concat(vec(body)))]));
    };
installMacro('when-some', expandWhenSome);
var expandWhenFirst = exports.expandWhenFirst = function expandWhenFirst(bindings) {
        var body = Array.prototype.slice.call(arguments, 1);
        return function () {
            var nameø1 = first(bindings);
            var testø1 = second(bindings);
            return list.apply(void 0, [symbol(void 0, 'when-let')].concat([[[nameø1].concat()].concat([list.apply(void 0, [symbol(void 0, 'seq*')].concat([testø1]))])], vec(body)));
        }.call(this);
    };
installMacro('when-first', expandWhenFirst);
var expandWhile = exports.expandWhile = function expandWhile(test) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'loop')].concat([[]], [list.apply(void 0, [symbol(void 0, 'when')].concat([test], vec(body), [list.apply(void 0, [symbol(void 0, 'recur')].concat())]))]));
    };
installMacro('while', expandWhile);
var expandDoto = exports.expandDoto = function expandDoto(x) {
        var forms = Array.prototype.slice.call(arguments, 1);
        return function () {
            var symø1 = gensym('doto-binding');
            return list.apply(void 0, [symbol(void 0, 'let')].concat([[symø1].concat([x])], vec(map(function ($1) {
                return concat([
                    first($1),
                    symø1
                ], rest($1));
            }, forms)), [symø1]));
        }.call(this);
    };
installMacro('doto', expandDoto);
var expandDotimes = exports.expandDotimes = function expandDotimes(bindings) {
        var body = Array.prototype.slice.call(arguments, 1);
        return function () {
            var nameø1 = first(bindings);
            var nø1 = second(bindings);
            var symø1 = gensym('dotimes-binding');
            return list.apply(void 0, [symbol(void 0, 'let')].concat([[symø1].concat([nø1])], [list.apply(void 0, [symbol(void 0, 'loop')].concat([[nameø1].concat([0])], [list.apply(void 0, [symbol(void 0, 'when')].concat([list.apply(void 0, [symbol(void 0, '<')].concat([nameø1], [symø1]))], vec(body), [list.apply(void 0, [symbol(void 0, 'recur')].concat([list.apply(void 0, [symbol(void 0, 'inc')].concat([nameø1]))]))]))]))]));
        }.call(this);
    };
installMacro('dotimes', expandDotimes);
var forStep = function forStep(context, loop) {
    var modifiers = Array.prototype.slice.call(arguments, 2);
    return function () {
        var iterø1 = (context || 0)['iter'];
        var collø1 = (context || 0)['coll'];
        var bodyø1 = (context || 0)['body'];
        var subseqø1 = (context || 0)['subseq'];
        var body_ø1 = !subseqø1 ? bodyø1 : list.apply(void 0, [symbol(void 0, 'let')].concat([[subseqø1].concat([bodyø1])], [list.apply(void 0, [symbol(void 0, 'if')].concat([list.apply(void 0, [symbol(void 0, 'empty?')].concat([subseqø1]))], [list.apply(void 0, [symbol(void 0, 'recur')].concat([list.apply(void 0, [symbol(void 0, 'rest')].concat([collø1]))]))], [list.apply(void 0, [symbol(void 0, 'lazy-concat')].concat([subseqø1], [list.apply(void 0, [iterø1].concat([list.apply(void 0, [symbol(void 0, 'rest')].concat([collø1]))]))]))]))]));
        var nextø1 = function loop() {
                var recur = loop;
                var modsø1 = reverse(modifiers);
                var bodyø2 = body_ø1;
                do {
                    recur = isEmpty(modsø1) ? bodyø2 : function () {
                        var mø1 = first(modsø1);
                        var itemø1 = first(mø1);
                        var argø1 = second(mø1);
                        return loop[0] = rest(modsø1), loop[1] = isEqual(itemø1, '\uA789let') ? list.apply(void 0, [symbol(void 0, 'let')].concat([argø1], [bodyø2])) : isEqual(itemø1, '\uA789while') ? list.apply(void 0, [symbol(void 0, 'if')].concat([argø1], [bodyø2])) : isEqual(itemø1, '\uA789when') ? list.apply(void 0, [symbol(void 0, 'if')].concat([argø1], [bodyø2], [list.apply(void 0, [symbol(void 0, 'recur')].concat([list.apply(void 0, [symbol(void 0, 'rest')].concat([collø1]))]))])) : void 0, loop;
                    }.call(this);
                } while (modsø1 = loop[0], bodyø2 = loop[1], recur === loop);
                return recur;
            }.call(this);
        return merge(context, {
            'subseq': gensym('for-subseq'),
            'body': list.apply(void 0, [list.apply(void 0, [symbol(void 0, 'fn')].concat([iterø1], [[collø1].concat()], [list.apply(void 0, [symbol(void 0, 'lazy-seq')].concat([list.apply(void 0, [symbol(void 0, 'loop')].concat([[collø1].concat([collø1])], [list.apply(void 0, [symbol(void 0, 'if-not')].concat([list.apply(void 0, [symbol(void 0, 'empty?')].concat([collø1]))], [list.apply(void 0, [symbol(void 0, 'let')].concat([[first(loop)].concat([list.apply(void 0, [symbol(void 0, 'first')].concat([collø1]))])], [nextø1]))]))]))]))]))].concat([second(loop)]))
        });
    }.call(this);
};
var forModifiers = set('\uA789let', '\uA789while', '\uA789when');
var forParts = function forParts(seqExprPairs) {
    return function () {
        var nø1 = count(seqExprPairs);
        var indicesø1 = filter(function ($1) {
                return !forModifiers(first(seqExprPairs[$1]));
            }, range(nø1));
        var segmentsø1 = partition(2, 1, conj(indicesø1, nø1));
        return map(function ($1) {
            return seqExprPairs.slice(first($1), second($1));
        }, segmentsø1);
    }.call(this);
};
var expandFor = exports.expandFor = function expandFor(seqExprs, bodyExpr) {
        return function () {
            var iterø1 = gensym('for-iter');
            var collø1 = gensym('for-coll');
            var partsø1 = forParts(partition(2, seqExprs));
            return (reduce(function ($1, $2) {
                return forStep.apply(void 0, [$1].concat($2));
            }, {
                'iter': iterø1,
                'coll': collø1,
                'body': list.apply(void 0, [symbol(void 0, 'cons')].concat([bodyExpr], [list.apply(void 0, [iterø1].concat([list.apply(void 0, [symbol(void 0, 'rest')].concat([collø1]))]))]))
            }, reverse(partsø1)) || 0)['body'];
        }.call(this);
    };
installMacro('for', expandFor);
var expandDoseq = exports.expandDoseq = function expandDoseq(seqExprs) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'dorun')].concat([list.apply(void 0, [symbol(void 0, 'for')].concat([seqExprs], [list.apply(void 0, [symbol(void 0, 'do')].concat(vec(body), [void 0]))]))]));
    };
installMacro('doseq', expandDoseq);
var sym_ = function sym_(string) {
    return function () {
        var wordsø1 = split(name(string), /-/);
        return join(cons(first(wordsø1), map(capitalize, rest(wordsø1))));
    }.call(this);
};
var bindSym_ = function bindSym_(s, b) {
    !isSymbol(s) ? (function () {
        throw Error('' + 'Assert failed: ' + 'Expected a symbol here!' + '(symbol? s)');
    })() : void 0;
    return [
        s,
        b
    ];
};
var conjSyms_ = function conjSyms_(get_, result, k, v, f, quote) {
    return function () {
        var kNsø1 = namespace(k);
        var gø1 = function ($1) {
            return f(kNsø1, name($1));
        };
        return vec(concat(result, mapcat(function ($1) {
            return bindSym_($1, get_($1, gø1($1), quote));
        }, v)));
    }.call(this);
};
var dictGet_ = function dictGet_(dictName, defaults) {
    return function (binding, key, quote) {
        return function () {
            var sø1 = name(key);
            var kø1 = keyword(namespace(key), isSymbol(key) ? sym_(sø1) : sø1);
            return list.apply(void 0, [symbol(void 0, 'get')].concat([dictName], [!quote ? kø1 : list.apply(void 0, [symbol(void 0, 'quote')].concat([kø1]))], [binding && defaults[binding]]));
        }.call(this);
    };
};
var destructureDict = exports.destructureDict = function destructureDict(binding, from) {
        return function () {
            var dictNameø1 = binding['\uA789as'] || gensym('destructure-bind');
            var dictBindø1 = list.apply(void 0, [symbol(void 0, 'if')].concat([list.apply(void 0, [symbol(void 0, 'dictionary?')].concat([dictNameø1]))], [dictNameø1], [list.apply(void 0, [symbol(void 0, 'apply')].concat([symbol(void 0, 'dictionary')], [list.apply(void 0, [symbol(void 0, 'vec')].concat([dictNameø1]))]))]));
            var get_ø1 = dictGet_(dictNameø1, get.apply(void 0, [
                    binding,
                    '\uA789or',
                    {}
                ]));
            return function loop() {
                var recur = loop;
                var ksø1 = keys(dissoc(binding, '\uA789as', '\uA789or'));
                var resultø1 = [
                        dictNameø1,
                        from,
                        dictNameø1,
                        dictBindø1
                    ];
                do {
                    recur = isEmpty(ksø1) ? resultø1 : function () {
                        var kø1 = first(ksø1);
                        var vø1 = (binding || 0)[kø1];
                        var k_ø1 = isKeyword(kø1) && name(kø1);
                        !(isSymbol(kø1) || k_ø1 && set('keys', 'strs', 'syms')(k_ø1)) ? (function () {
                            throw Error('' + 'Assert failed: ' + ('' + 'Invalid destructure key ' + kø1) + '(or (symbol? k) (and k* ((set :keys :strs :syms) k*)))');
                        })() : void 0;
                        return loop[0] = rest(ksø1), loop[1] = isEqual(k_ø1, 'strs') ? conjSyms_(get_ø1, resultø1, kø1, vø1, keyword) : isEqual(k_ø1, 'syms') ? conjSyms_(get_ø1, resultø1, kø1, vø1, function ($1, $2) {
                            return symbol($1, sym_($2));
                        }) : isEqual(k_ø1, 'keys') ? conjSyms_(get_ø1, resultø1, kø1, vø1, keyword, 'quote') : isNumber(vø1) ? conj(resultø1, kø1, get_ø1(kø1, symbol('' + vø1))) : 'else' ? conj(resultø1, kø1, get_ø1(kø1, vø1)) : void 0, loop;
                    }.call(this);
                } while (ksø1 = loop[0], resultø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var destructureSeq = exports.destructureSeq = function destructureSeq(binding, from) {
        return function () {
            var asø1 = binding.findIndex(function ($1) {
                    return isEqual($1, '\uA789as');
                });
            var seqNameø1 = asø1 < 0 ? gensym('destructure-bind') : nth(binding, inc(asø1));
            var binding1ø1 = asø1 < 0 ? binding : take(asø1, binding);
            var moreø1 = binding1ø1.findIndex(function ($1) {
                    return isEqual($1, symbol(void 0, '&'));
                });
            var tailø1 = moreø1 >= 0 ? nth(binding1ø1, inc(moreø1)) : void 0;
            var binding2ø1 = moreø1 < 0 ? binding1ø1 : take(moreø1, binding);
            !(asø1 < 0 || isEqual(asø1, count(binding) - 2)) ? (function () {
                throw Error('' + 'Assert failed: ' + 'invalid :as in seq-destructuring' + '(or (< as 0) (= as (- (count binding) 2)))');
            })() : void 0;
            !(moreø1 < 0 || isEqual(moreø1, count(binding1ø1) - 2)) ? (function () {
                throw Error('' + 'Assert failed: ' + 'invalid & in seq-destructuring' + '(or (< more 0) (= more (- (count binding1) 2)))');
            })() : void 0;
            return function loop() {
                var recur = loop;
                var xsø1 = binding2ø1;
                var iø1 = 0;
                var resultø1 = [
                        seqNameø1,
                        from
                    ];
                do {
                    recur = function () {
                        var xø1 = first(xsø1);
                        return isEmpty(xsø1) ? !tailø1 ? resultø1 : conj(resultø1, tailø1, list.apply(void 0, [symbol(void 0, 'drop')].concat([moreø1], [seqNameø1]))) : isEqual(xø1, symbol(void 0, '_')) ? (loop[0] = rest(xsø1), loop[1] = inc(iø1), loop[2] = resultø1, loop) : 'else' ? (loop[0] = rest(xsø1), loop[1] = inc(iø1), loop[2] = conj(resultø1, xø1, list.apply(void 0, [symbol(void 0, 'nth')].concat([seqNameø1], [iø1]))), loop) : void 0;
                    }.call(this);
                } while (xsø1 = loop[0], iø1 = loop[1], resultø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var destructure = exports.destructure = function destructure(bindings) {
        return function () {
            var pairsø1 = partition(2, bindings);
            return isEvery(function ($1) {
                return isSymbol(first($1));
            }, pairsø1) ? bindings : destructure(vec(mapcat(function ($1) {
                return isVector(first($1)) ? destructureSeq.apply(void 0, $1) : isDictionary(first($1)) ? destructureDict.apply(void 0, $1) : isSymbol(first($1)) ? $1 : 'else' ? (function () {
                    throw 'Invalid binding';
                })() : void 0;
            }, pairsø1)));
        }.call(this);
    };
var bindNames_ = function bindNames_(keys) {
    return zipmap(keys, repeatedly(count(keys), function () {
        return gensym('destructure-bind');
    }));
};
var bindIndices_ = function bindIndices_(names) {
    return filter(function ($1) {
        return !isSymbol(nth(names, $1));
    }, range(count(names)));
};
var expandLet = exports.expandLet = function expandLet(bindings) {
        var body = Array.prototype.slice.call(arguments, 1);
        return list.apply(void 0, [symbol(void 0, 'let*')].concat([destructure(bindings)], vec(body)));
    };
installMacro('let', expandLet);
var expandFn = exports.expandFn = function expandFn() {
        var args = Array.prototype.slice.call(arguments, 0);
        return function () {
            var nameø1 = isSymbol(first(args)) ? first(args) : void 0;
            var defsø1 = nameø1 ? rest(args) : args;
            var mkfnø1 = function ($1) {
                return nameø1 ? list.apply(void 0, [symbol(void 0, 'fn*')].concat([nameø1], vec($1))) : list.apply(void 0, [symbol(void 0, 'fn*')].concat(vec($1)));
            };
            var def_ø1 = function (args) {
                var body = Array.prototype.slice.call(arguments, 1);
                return function () {
                    var indicesø1 = bindIndices_(args);
                    var namesø1 = bindNames_(indicesø1);
                    return isEmpty(namesø1) ? cons(args, body) : list.apply(void 0, [vec(mapIndexed(function ($1, $2) {
                            return get.apply(void 0, [
                                namesø1,
                                $1,
                                $2
                            ]);
                        }, args))].concat([list.apply(void 0, [symbol(void 0, 'let')].concat([vec(mapcat(function (i) {
                                return [
                                    args[i],
                                    namesø1[i]
                                ];
                            }, indicesø1))], vec(body)))]));
                }.call(this);
            };
            return isVector(first(defsø1)) ? mkfnø1(def_ø1.apply(void 0, defsø1)) : mkfnø1(map(function ($1) {
                return def_ø1.apply(void 0, vec($1));
            }, defsø1));
        }.call(this);
    };
installMacro('fn', expandFn);
var expandLoop = exports.expandLoop = function expandLoop(bindings) {
        var body = Array.prototype.slice.call(arguments, 1);
        return function () {
            var pairsø1 = partition(2, bindings);
            var indicesø1 = bindIndices_(mapv(first, pairsø1));
            var namesø1 = bindNames_(indicesø1);
            var get_ø1 = function ($1, $2) {
                return function () {
                    var ifLetBinding1ø1 = namesø1[$1];
                    return ifLetBinding1ø1 ? function () {
                        var xø1 = ifLetBinding1ø1;
                        return [
                            xø1,
                            second($2),
                            first($2),
                            xø1
                        ];
                    }.call(this) : $2;
                }.call(this);
            };
            return isEmpty(namesø1) ? list.apply(void 0, [symbol(void 0, 'loop*')].concat([bindings], vec(body))) : list.apply(void 0, [symbol(void 0, 'let')].concat([vec(concat.apply(void 0, mapIndexed(get_ø1, pairsø1)))], [list.apply(void 0, [symbol(void 0, 'loop*')].concat([vec(concat.apply(void 0, mapIndexed(function ($1, $2) {
                        return function () {
                            var xø1 = get.apply(void 0, [
                                    namesø1,
                                    $1,
                                    first($2)
                                ]);
                            return [
                                xø1,
                                xø1
                            ];
                        }.call(this);
                    }, pairsø1)))], [list.apply(void 0, [symbol(void 0, 'let')].concat([vec(mapcat(function (i) {
                            return [
                                first(pairsø1[i]),
                                namesø1[i]
                            ];
                        }, indicesø1))], vec(body)))]))]));
        }.call(this);
    };
installMacro('loop', expandLoop);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsIm1ldGEiLCJ3aXRoTWV0YSIsImlzU3ltYm9sIiwiaXNLZXl3b3JkIiwia2V5d29yZCIsImlzUXVvdGUiLCJzeW1ib2wiLCJuYW1lc3BhY2UiLCJuYW1lIiwiZ2Vuc3ltIiwiaXNVbnF1b3RlIiwiaXNVbnF1b3RlU3BsaWNpbmciLCJpc0xpc3QiLCJsaXN0IiwiY29uaiIsInBhcnRpdGlvbiIsInNlcSIsInJlcGVhdGVkbHkiLCJpc0VtcHR5IiwibWFwIiwibWFwdiIsInZlYyIsInNldCIsImlzRXZlcnkiLCJjb25jYXQiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsImxhc3QiLCJtYXBjYXQiLCJudGgiLCJidXRsYXN0IiwiaW50ZXJsZWF2ZSIsImNvbnMiLCJjb3VudCIsInRha2UiLCJkaXNzb2MiLCJzb21lIiwiYXNzb2MiLCJyZWR1Y2UiLCJmaWx0ZXIiLCJpc1NlcSIsInppcG1hcCIsImRyb3AiLCJsYXp5U2VxIiwicmFuZ2UiLCJyZXZlcnNlIiwiZG9ydW4iLCJtYXBJbmRleGVkIiwiaXNOaWwiLCJpc0RpY3Rpb25hcnkiLCJpc1ZlY3RvciIsImtleXMiLCJnZXQiLCJ2YWxzIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzQm9vbGVhbiIsImlzRGF0ZSIsImlzUmVQYXR0ZXJuIiwiaXNFdmVuIiwiaXNPZGQiLCJpc0VxdWFsIiwibWF4IiwiaW5jIiwiZGVjIiwiZGljdGlvbmFyeSIsIm1lcmdlIiwic3VicyIsInNwbGl0Iiwiam9pbiIsImNhcGl0YWxpemUiLCJfX21hY3Jvc19fIiwiZXhwb3J0cyIsImV4cGFuZCIsImV4cGFuZGVyIiwiZm9ybSIsImVudiIsIm1ldGFkYXRhw7gxIiwicGFybWFzw7gxIiwiaW1wbGljaXTDuDEiLCIkMSIsInBhcmFtc8O4MSIsImV4cGFuc2lvbsO4MSIsImluc3RhbGxNYWNybyIsIm9wIiwibWFjcm8iLCJpc0RvdFN5bnRheCIsImlzTWV0aG9kU3ludGF4IiwiaWTDuDEiLCJpc0ZpZWxkU3ludGF4IiwiaXNOZXdTeW50YXgiLCJtZXRob2RTeW50YXgiLCJ0YXJnZXQiLCJwYXJhbXMiLCJvcE1ldGHDuDEiLCJmb3JtU3RhcnTDuDEiLCJ0YXJnZXRNZXRhw7gxIiwibWVtYmVyw7gxIiwiYWdldMO4MSIsIm1ldGhvZMO4MSIsIkVycm9yIiwiZmllbGRTeW50YXgiLCJmaWVsZCIsIm1vcmUiLCJzdGFydMO4MSIsImVuZMO4MSIsImRvdFN5bnRheCIsIl9maWVsZMO4MSIsIm5ld1N5bnRheCIsImlkTWV0YcO4MSIsInJlbmFtZcO4MSIsImNvbnN0cnVjdG9yw7gxIiwib3BlcmF0b3LDuDEiLCJrZXl3b3JkSW52b2tlIiwiZGVmYXVsdF8iLCJkZXN1Z2FyIiwiZGVzdWdhcmVkw7gxIiwibWFjcm9leHBhbmQxIiwib3DDuDEiLCJleHBhbmRlcsO4MSIsIm1hY3JvZXhwYW5kIiwib3JpZ2luYWzDuDEiLCJleHBhbmRlZMO4MSIsInN5bnRheFF1b3RlIiwicmVhZGVyRXJyb3IiLCJzZXF1ZW5jZUV4cGFuZCIsInN5bnRheFF1b3RlRXhwYW5kIiwidW5xdW90ZVNwbGljaW5nRXhwYW5kIiwiZm9ybXMiLCJleHBhbmROb3RFcXVhbCIsImJvZHkiLCJleHBhbmRJZk5vdCIsImNvbmRpdGlvbiIsInRydXRoeSIsImFsdGVybmF0aXZlIiwiZXhwYW5kQ29tbWVudCIsImV4cGFuZFRocmVhZEZpcnN0Iiwib3BlcmF0aW9ucyIsIm9wZXJhdGlvbiIsImV4cGFuZFRocmVhZExhc3QiLCJleHBhbmREb3RzIiwieCIsImV4cGFuZFRocmVhZEFzIiwiZXhwciIsImV4cGFuZENvbmQiLCJjbGF1c2VzIiwiZXhwYW5kQ2FzZSIsImUiLCJzeW3DuDEiLCJwYWlyc8O4MSIsImVxX8O4MSIsImMiLCJ0YWlsw7gxIiwicGFpcnPDuDIiLCJjb25kc8O4MSIsInJlc3VsdMO4MSIsInjDuDEiLCJ4c8O4MSIsImNvbnN0c8O4MSIsInJlc8O4MSIsImV4cGFuZENvbmRwIiwicHJlZCIsInN5bV/DuDEiLCJjb21wYXJlw7gxIiwic3BsaXRzw7gxIiwic3BsaXRzIiwieHMiLCJfdGhyZWFkIiwiaW5zZXJ0Iiwic3ltIiwidGVzdCIsImZvcm3DuDIiLCJfY29uZFRocmVhZCIsImV4cGFuZENvbmRUaHJlYWRGaXJzdCIsImV4cGFuZENvbmRUaHJlYWRMYXN0IiwiX3NvbWVUaHJlYWQiLCJleHBhbmRTb21lVGhyZWFkRmlyc3QiLCJleHBhbmRTb21lVGhyZWFkTGFzdCIsImV4cGFuZERlZm4iLCJfYW5kRm9ybSIsImRvY1BsdXNNZXRhUGx1c0JvZHkiLCJkb2PDuDEiLCJtZXRhUGx1c0JvZHnDuDEiLCJib2R5w7gxIiwiZm7DuDEiLCJleHBhbmRQcml2YXRlRGVmbiIsImV4cGFuZExhenlTZXEiLCJleHBhbmRXaGVuIiwiZXhwYW5kV2hlbk5vdCIsImV4cGFuZElmTGV0IiwiYmluZGluZ3MiLCJ0aGVuIiwiZWxzZV8iLCJuYW1lw7gxIiwidGVzdMO4MSIsImV4cGFuZFdoZW5MZXQiLCJleHBhbmRJZlNvbWUiLCJleHBhbmRXaGVuU29tZSIsImV4cGFuZFdoZW5GaXJzdCIsImV4cGFuZFdoaWxlIiwiZXhwYW5kRG90byIsImV4cGFuZERvdGltZXMiLCJuw7gxIiwiZm9yU3RlcCIsImNvbnRleHQiLCJsb29wIiwibW9kaWZpZXJzIiwiaXRlcsO4MSIsImNvbGzDuDEiLCJzdWJzZXHDuDEiLCJib2R5X8O4MSIsIm5leHTDuDEiLCJtb2Rzw7gxIiwiYm9kecO4MiIsIm3DuDEiLCJpdGVtw7gxIiwiYXJnw7gxIiwiZm9yTW9kaWZpZXJzIiwiZm9yUGFydHMiLCJzZXFFeHByUGFpcnMiLCJpbmRpY2Vzw7gxIiwic2VnbWVudHPDuDEiLCJzbGljZSIsImV4cGFuZEZvciIsInNlcUV4cHJzIiwiYm9keUV4cHIiLCJwYXJ0c8O4MSIsIiQyIiwiZXhwYW5kRG9zZXEiLCJzeW1fIiwic3RyaW5nIiwid29yZHPDuDEiLCJiaW5kU3ltXyIsInMiLCJiIiwiY29ualN5bXNfIiwiZ2V0XyIsInJlc3VsdCIsImsiLCJ2IiwiZiIsInF1b3RlIiwia05zw7gxIiwiZ8O4MSIsImRpY3RHZXRfIiwiZGljdE5hbWUiLCJkZWZhdWx0cyIsImJpbmRpbmciLCJrZXkiLCJzw7gxIiwia8O4MSIsImRlc3RydWN0dXJlRGljdCIsImZyb20iLCJkaWN0TmFtZcO4MSIsImRpY3RCaW5kw7gxIiwiZ2V0X8O4MSIsImtzw7gxIiwidsO4MSIsImtfw7gxIiwiZGVzdHJ1Y3R1cmVTZXEiLCJhc8O4MSIsImZpbmRJbmRleCIsInNlcU5hbWXDuDEiLCJiaW5kaW5nMcO4MSIsIm1vcmXDuDEiLCJiaW5kaW5nMsO4MSIsImnDuDEiLCJkZXN0cnVjdHVyZSIsImJpbmROYW1lc18iLCJiaW5kSW5kaWNlc18iLCJuYW1lcyIsImV4cGFuZExldCIsImV4cGFuZEZuIiwiYXJncyIsImRlZnPDuDEiLCJta2Zuw7gxIiwiZGVmX8O4MSIsIm5hbWVzw7gxIiwiaSIsImV4cGFuZExvb3AiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksZUFBSjtBQUFBLFlBQUFDLEcsRUFDRSx1Q0FERjtBQUFBLFU7O1FBRThCQyxJQUFBLEcsU0FBQUEsSTtRQUFLQyxRQUFBLEcsU0FBQUEsUTtRQUFVQyxRQUFBLEcsU0FBQUEsUTtRQUFRQyxTQUFBLEcsU0FBQUEsUztRQUFTQyxPQUFBLEcsU0FBQUEsTztRQUNoQ0MsT0FBQSxHLFNBQUFBLE87UUFBT0MsTUFBQSxHLFNBQUFBLE07UUFBT0MsU0FBQSxHLFNBQUFBLFM7UUFBVUMsSUFBQSxHLFNBQUFBLEk7UUFBS0MsTUFBQSxHLFNBQUFBLE07UUFDN0JDLFNBQUEsRyxTQUFBQSxTO1FBQVNDLGlCQUFBLEcsU0FBQUEsaUI7O1FBQ0pDLE1BQUEsRyxjQUFBQSxNO1FBQU1DLElBQUEsRyxjQUFBQSxJO1FBQUtDLElBQUEsRyxjQUFBQSxJO1FBQUtDLFNBQUEsRyxjQUFBQSxTO1FBQVVDLEdBQUEsRyxjQUFBQSxHO1FBQUlDLFVBQUEsRyxjQUFBQSxVO1FB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USxPQUFXNUQsSSxFQUFwQixDQURGLEcsVUFFRSxDLE1BQUEsRSxPQUFFLEMsTUFBQSxFLEtBQUEsQyxVQUFNL0csR0FBRCxDQUFZRyxNLE1BQVAsQyxNQUFBLEVBQWV5QixVQUFELENBQWFnTixNQUFiLEVBQWtCMUcsT0FBbEIsQ0FBZCxDQUFMLEMsOEJBQ0gsQyxNQUFBLEUsT0FBQSxDLFVBQVFsSSxHQUFELENBQVlHLE0sTUFBUCxDLE1BQUEsRUFBZXlCLFVBQUQsQ0FBYSxVQUFvQmlDLEVBQXBCLEVBQThCbUosRUFBOUIsRTsyQ0FBTztBQUFBLGdDQUFBdkUsRyxZQUFFLEMsTUFBQSxFO29DQUFLeUgsTztvQ0FBTXJNLEU7b0NBQUl6RCxLQUFELENBQU80TSxFQUFQLEM7aUNBQWQsQ0FBRjtBQUFBLDRCQUE2QjtBQUFBLGdDQUFDdkUsR0FBRDtBQUFBLGdDQUFHQSxHQUFIO0FBQUEsOEJBQTdCO0FBQUEseUI7cUJBQXBCLEVBQ2FQLE9BRGIsQ0FBZCxDQUFMLEMsOEJBRUwsQyxNQUFBLEUsS0FBQSxDLFVBQU1sSSxHQUFELENBQU1TLE1BQUQsQ0FBUSxVQUFLMFAsQ0FBTCxFQUFRO0FBQUE7QUFBQSxnQ0FBRS9QLEtBQUQsQ0FBYThILE9BQU4sQ0FBWWlJLENBQVosQ0FBUCxDQUFEO0FBQUEsZ0NBQThCRCxPQUFOLENBQVlDLENBQVosQ0FBeEI7QUFBQTtBQUFBLHlCQUFoQixFQUNRMUQsU0FEUixDQUFMLEMsT0FFRjFGLEksUUFMVCxDQUZGLENBTkk7QUFBQSxTLEtBQU4sQyxJQUFBLEU7S0FQRixDO0FBcUJDL0MsWUFBRCxDLE1BQUEsRUFBcUJvTSxVQUFyQiIsInNvdXJjZXNDb250ZW50IjpbIihucyB3aXNwLmV4cGFuZGVyXG4gIFwid2lzcCBzeW50YXggYW5kIG1hY3JvIGV4cGFuZGVyIG1vZHVsZVwiXG4gICg6cmVxdWlyZSBbd2lzcC5hc3QgOnJlZmVyIFttZXRhIHdpdGgtbWV0YSBzeW1ib2w/IGtleXdvcmQ/IGtleXdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlPyBzeW1ib2wgbmFtZXNwYWNlIG5hbWUgZ2Vuc3ltXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlPyB1bnF1b3RlLXNwbGljaW5nP11dXG4gICAgICAgICAgICBbd2lzcC5zZXF1ZW5jZSA6cmVmZXIgW2xpc3Q/IGxpc3QgY29uaiBwYXJ0aXRpb24gc2VxIHJlcGVhdGVkbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHk/IG1hcCBtYXB2IHZlYyBzZXQgZXZlcnk/IGNvbmNhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCBzZWNvbmQgdGhpcmQgcmVzdCBsYXN0IG1hcGNhdCBudGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0bGFzdCBpbnRlcmxlYXZlIGNvbnMgY291bnQgdGFrZSBkaXNzb2NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29tZSBhc3NvYyByZWR1Y2UgZmlsdGVyIHNlcT8gemlwbWFwIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF6eS1zZXEgcmFuZ2UgcmV2ZXJzZSBkb3J1biBtYXAtaW5kZXhlZF1dXG4gICAgICAgICAgICBbd2lzcC5ydW50aW1lIDpyZWZlciBbbmlsPyBkaWN0aW9uYXJ5PyB2ZWN0b3I/IGtleXMgZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFscyBzdHJpbmc/IG51bWJlcj8gYm9vbGVhbj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlPyByZS1wYXR0ZXJuPyBldmVuPyBvZGQ/ID0gbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jIGRlYyBkaWN0aW9uYXJ5IG1lcmdlIHN1YnNdXVxuICAgICAgICAgICAgW3dpc3Auc3RyaW5nIDpyZWZlciBbc3BsaXQgam9pbiBjYXBpdGFsaXplXV0pKVxuXG5cbihkZWYgKiptYWNyb3MqKiB7fSlcblxuKGRlZm4tIGV4cGFuZFxuICBcIkFwcGxpZXMgbWFjcm8gcmVnaXN0ZXJlZCB3aXRoIGdpdmVuIGBuYW1lYCB0byBhIGdpdmVuIGBmb3JtYFwiXG4gIFtleHBhbmRlciBmb3JtIGVudl1cbiAgKGxldCBbbWV0YWRhdGEgKG9yIChtZXRhIGZvcm0pIHt9KVxuICAgICAgICBwYXJtYXMgKHJlc3QgZm9ybSlcbiAgICAgICAgaW1wbGljaXQgKG1hcCAjKGNvbmQgKD0gOiZmb3JtICUpIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKD0gOiZlbnYgJSkgZW52XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbHNlICUpXG4gICAgICAgICAgICAgICAgICAgICAgKG9yICg6aW1wbGljaXQgKG1ldGEgZXhwYW5kZXIpKSBbXSkpXG4gICAgICAgIHBhcmFtcyAodmVjIChjb25jYXQgaW1wbGljaXQgKHZlYyAocmVzdCBmb3JtKSkpKVxuXG4gICAgICAgIGV4cGFuc2lvbiAoYXBwbHkgZXhwYW5kZXIgcGFyYW1zKV1cbiAgICAoaWYgZXhwYW5zaW9uXG4gICAgICAod2l0aC1tZXRhIGV4cGFuc2lvbiAoY29uaiBtZXRhZGF0YSAobWV0YSBleHBhbnNpb24pKSlcbiAgICAgIGV4cGFuc2lvbikpKVxuXG4oZGVmbiBpbnN0YWxsLW1hY3JvIVxuICBcIlJlZ2lzdGVycyBnaXZlbiBgbWFjcm9gIHdpdGggYSBnaXZlbiBgbmFtZWBcIlxuICBbb3AgZXhwYW5kZXJdXG4gIChzZXQhIChnZXQgKiptYWNyb3MqKiAobmFtZSBvcCkpIGV4cGFuZGVyKSlcblxuKGRlZm4tIG1hY3JvXG4gIFwiUmV0dXJucyB0cnVlIGlmIG1hY3JvIHdpdGggYSBnaXZlbiBuYW1lIGlzIHJlZ2lzdGVyZWRcIlxuICBbb3BdXG4gIChhbmQgKHN5bWJvbD8gb3ApXG4gICAgICAgKGdldCAqKm1hY3JvcyoqIChuYW1lIG9wKSkpKVxuXG5cbihkZWZuIGRvdC1zeW50YXg/XG4gIFtvcF1cbiAgKGFuZCAoc3ltYm9sPyBvcCkgKGlkZW50aWNhbD8gXFwuIChuYW1lIG9wKSkpKVxuXG4oZGVmbiBtZXRob2Qtc3ludGF4P1xuICBbb3BdXG4gIChsZXQgW2lkIChhbmQgKHN5bWJvbD8gb3ApIChuYW1lIG9wKSldXG4gICAgKGFuZCBpZFxuICAgICAgICAgKGlkZW50aWNhbD8gXFwuIChmaXJzdCBpZCkpXG4gICAgICAgICAobm90IChpZGVudGljYWw/IFxcLSAoc2Vjb25kIGlkKSkpXG4gICAgICAgICAobm90IChpZGVudGljYWw/IFxcLiBpZCkpKSkpXG5cbihkZWZuIGZpZWxkLXN5bnRheD9cbiAgW29wXVxuICAobGV0IFtpZCAoYW5kIChzeW1ib2w/IG9wKSAobmFtZSBvcCkpXVxuICAgIChhbmQgaWRcbiAgICAgICAgIChpZGVudGljYWw/IFxcLiAoZmlyc3QgaWQpKVxuICAgICAgICAgKGlkZW50aWNhbD8gXFwtIChzZWNvbmQgaWQpKSkpKVxuXG4oZGVmbiBuZXctc3ludGF4P1xuICBbb3BdXG4gIChsZXQgW2lkIChhbmQgKHN5bWJvbD8gb3ApIChuYW1lIG9wKSldXG4gICAgKGFuZCBpZFxuICAgICAgICAgKGlkZW50aWNhbD8gXFwuIChsYXN0IGlkKSlcbiAgICAgICAgIChub3QgKGlkZW50aWNhbD8gXFwuIGlkKSkpKSlcblxuKGRlZm4gbWV0aG9kLXN5bnRheFxuICBcIkV4YW1wbGU6XG4gICcoLnN1YnN0cmluZyBzdHJpbmcgMiA1KSA9PiAnKChhZ2V0IHN0cmluZyAnc3Vic3RyaW5nKSAyIDUpXCJcbiAgW29wIHRhcmdldCAmIHBhcmFtc11cbiAgKGxldCBbb3AtbWV0YSAobWV0YSBvcClcbiAgICAgICAgZm9ybS1zdGFydCAoOnN0YXJ0IG9wLW1ldGEpXG4gICAgICAgIHRhcmdldC1tZXRhIChtZXRhIHRhcmdldClcbiAgICAgICAgbWVtYmVyICh3aXRoLW1ldGEgKHN5bWJvbCAoc3VicyAobmFtZSBvcCkgMSkpXG4gICAgICAgICAgICAgICAgIDs7IEluY2x1ZGUgbWV0YWRhdCBmcm9tIHRoZSBvcmlnaW5hbCBzeW1ib2wganVzdFxuICAgICAgICAgICAgICAgICAoY29uaiBvcC1tZXRhXG4gICAgICAgICAgICAgICAgICAgICAgIHs6c3RhcnQgezpsaW5lICg6bGluZSBmb3JtLXN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y29sdW1uIChpbmMgKDpjb2x1bW4gZm9ybS1zdGFydCkpfX0pKVxuICAgICAgICA7OyBBZGQgbWV0YWRhdGEgdG8gYWdldCBzeW1ib2wgdGhhdCB3aWxsIG1hcCB0byB0aGUgZmlyc3QgYC5gXG4gICAgICAgIDs7IGNoYXJhY3RlciBvZiB0aGUgbWV0aG9kIG5hbWUuXG4gICAgICAgIGFnZXQgKHdpdGgtbWV0YSAnYWdldFxuICAgICAgICAgICAgICAgKGNvbmogb3AtbWV0YVxuICAgICAgICAgICAgICAgICAgICAgezplbmQgezpsaW5lICg6bGluZSBmb3JtLXN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKGluYyAoOmNvbHVtbiBmb3JtLXN0YXJ0KSl9fSkpXG5cbiAgICAgICAgOzsgRmlyc3QgdHdvIGZvcm1zICguc3Vic3RyaW5nIHN0cmluZyAuLi4pIGV4cGFuZCB0b1xuICAgICAgICA7OyAoKGFnZXQgc3RyaW5nICdzdWJzdHJpbmcpIC4uLikgdGhlcmUgZm9yIGV4cGFuc2lvbiBnZXRzXG4gICAgICAgIDs7IHBvc2l0aW9uIG1ldGFkYXRhIGZyb20gc3RhcnQgb2YgdGhlIGZpcnN0IGAuc3Vic3RyaW5nYCBmb3JtXG4gICAgICAgIDs7IHRvIHRoZSBlbmQgb2YgdGhlIGBzdHJpbmdgIGZvcm0uXG4gICAgICAgIG1ldGhvZCAod2l0aC1tZXRhIGAofmFnZXQgfnRhcmdldCAocXVvdGUgfm1lbWJlcikpXG4gICAgICAgICAgICAgICAgIChjb25qIG9wLW1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgezplbmQgKDplbmQgKG1ldGEgdGFyZ2V0KSl9KSldXG4gICAgKGlmIChuaWw/IHRhcmdldClcbiAgICAgICh0aHJvdyAoRXJyb3IgXCJNYWxmb3JtZWQgbWV0aG9kIGV4cHJlc3Npb24sIGV4cGVjdGluZyAoLm1ldGhvZCBvYmplY3QgLi4uKVwiKSlcbiAgICAgIGAofm1ldGhvZCB+QHBhcmFtcykpKSlcblxuKGRlZm4gZmllbGQtc3ludGF4XG4gIFwiRXhhbXBsZTpcbiAgJyguLWZpZWxkIG9iamVjdCkgPT4gJyhhZ2V0IG9iamVjdCAnZmllbGQpXCJcbiAgW2ZpZWxkIHRhcmdldCAmIG1vcmVdXG4gIChsZXQgW21ldGFkYXRhIChtZXRhIGZpZWxkKVxuICAgICAgICBzdGFydCAoOnN0YXJ0IG1ldGFkYXRhKVxuICAgICAgICBlbmQgKDplbmQgbWV0YWRhdGEpXG4gICAgICAgIG1lbWJlciAod2l0aC1tZXRhIChzeW1ib2wgKHN1YnMgKG5hbWUgZmllbGQpIDIpKVxuICAgICAgICAgICAgICAgICAoY29uaiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICB7OnN0YXJ0IHs6bGluZSAoOmxpbmUgc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKCsgKDpjb2x1bW4gc3RhcnQpIDIpfX0pKV1cbiAgICAoaWYgKG9yIChuaWw/IHRhcmdldClcbiAgICAgICAgICAgIChjb3VudCBtb3JlKSlcbiAgICAgICh0aHJvdyAoRXJyb3IgXCJNYWxmb3JtZWQgbWVtYmVyIGV4cHJlc3Npb24sIGV4cGVjdGluZyAoLi1tZW1iZXIgdGFyZ2V0KVwiKSlcbiAgICAgIGAoYWdldCB+dGFyZ2V0IChxdW90ZSB+bWVtYmVyKSkpKSlcblxuKGRlZm4gZG90LXN5bnRheFxuICBcIkV4YW1wbGU6XG4gICcoLiBvYmplY3QgLWZpZWxkKSA9PiAnKGFnZXQgb2JqZWN0ICdmaWVsZClcbiAgJyguIHN0cmluZyBzdWJzdHJpbmcgMiA1KSA9PiAnKChhZ2V0IHN0cmluZyAnc3Vic3RyaW5nKSAyIDUpXCJcbiAgW29wIHRhcmdldCBmaWVsZCAmIHBhcmFtc11cbiAgKGlmLW5vdCAoc3ltYm9sPyBmaWVsZClcbiAgICAodGhyb3cgKEVycm9yIFwiTWFsZm9ybWVkIC4gZm9ybVwiKSkpXG4gIChsZXQgWypmaWVsZCAobmFtZSBmaWVsZCldXG4gICAgKGFwcGx5IChpZiAoaWRlbnRpY2FsPyBcXC0gKGZpcnN0ICpmaWVsZCkpIGZpZWxkLXN5bnRheCBtZXRob2Qtc3ludGF4KVxuICAgICAgICAgICAoc3ltYm9sIChzdHIgXFwuICpmaWVsZCkpIHRhcmdldCBwYXJhbXMpKSlcblxuKGRlZm4gbmV3LXN5bnRheFxuICBcIkV4YW1wbGU6XG4gICcoUG9pbnQuIHggeSkgPT4gJyhuZXcgUG9pbnQgeCB5KVwiXG4gIFtvcCAmIHBhcmFtc11cbiAgKGxldCBbaWQgKG5hbWUgb3ApXG4gICAgICAgIGlkLW1ldGEgKDptZXRhIGlkKVxuICAgICAgICByZW5hbWUgKHN1YnMgaWQgMCAoZGVjIChjb3VudCBpZCkpKVxuICAgICAgICA7OyBjb25zdHJ1Y3R1ciBzeW1ib2wgaW5oZXJpdHMgbWV0YWRhIGZyb20gdGhlIGZpcnN0IGBvcGAgZm9ybVxuICAgICAgICA7OyBpdCdzIGp1c3QgaXQncyBlbmQgY29sdW1uIGluZm8gaXMgdXBkYXRlZCB0byByZWZsZWN0IHN1YnRyYWN0aW9uXG4gICAgICAgIDs7IG9mIGAuYCBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0cnVjdG9yICh3aXRoLW1ldGEgKHN5bWJvbCByZW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgKGNvbmogaWQtbWV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZW5kIHs6bGluZSAoOmxpbmUgKDplbmQgaWQtbWV0YSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKGRlYyAoOmNvbHVtbiAoOmVuZCBpZC1tZXRhKSkpfX0pKVxuICAgICAgICBvcGVyYXRvciAod2l0aC1tZXRhICduZXdcbiAgICAgICAgICAgICAgICAgICAoY29uaiBpZC1tZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgezpzdGFydCB7OmxpbmUgKDpsaW5lICg6ZW5kIGlkLW1ldGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKGRlYyAoOmNvbHVtbiAoOmVuZCBpZC1tZXRhKSkpfX0pKV1cbiAgICBgKG5ldyB+Y29uc3RydWN0b3IgfkBwYXJhbXMpKSlcblxuKGRlZm4ga2V5d29yZC1pbnZva2VcbiAgXCJDYWxsaW5nIGEga2V5d29yZCBkZXN1Z2FycyB0byBwcm9wZXJ0eSBhY2Nlc3Mgd2l0aCB0aGF0XG4gIGtleXdvcmQgbmFtZSBvbiB0aGUgZ2l2ZW4gYXJndW1lbnQ6XG4gICcoOmZvbyBiYXIpID0+ICcoZ2V0IGJhciA6Zm9vKVwiXG4gIChba2V5d29yZCB0YXJnZXRdXG4gICAgYChnZXQgfnRhcmdldCB+a2V5d29yZCkpXG4gIChba2V5d29yZCB0YXJnZXQgZGVmYXVsdCpdXG4gICAgYChnZXQgfnRhcmdldCB+a2V5d29yZCB+ZGVmYXVsdCopKSlcblxuKGRlZm4tIGRlc3VnYXJcbiAgW2V4cGFuZGVyIGZvcm1dXG4gIChsZXQgW2Rlc3VnYXJlZCAoYXBwbHkgZXhwYW5kZXIgKHZlYyBmb3JtKSlcbiAgICAgICAgbWV0YWRhdGEgKGNvbmoge30gKG1ldGEgZm9ybSkgKG1ldGEgZGVzdWdhcmVkKSldXG4gICAgKHdpdGgtbWV0YSBkZXN1Z2FyZWQgbWV0YWRhdGEpKSlcblxuKGRlZm4gbWFjcm9leHBhbmQtMVxuICBcIklmIGZvcm0gcmVwcmVzZW50cyBhIG1hY3JvIGZvcm0sIHJldHVybnMgaXRzIGV4cGFuc2lvbixcbiAgZWxzZSByZXR1cm5zIGZvcm0uXCJcbiAgW2Zvcm0gZW52XVxuICAobGV0IFtvcCAoYW5kIChsaXN0PyBmb3JtKVxuICAgICAgICAgICAgICAgIChmaXJzdCBmb3JtKSlcbiAgICAgICAgZXhwYW5kZXIgKG1hY3JvIG9wKV1cbiAgICAoY29uZCBleHBhbmRlciAoZXhwYW5kIGV4cGFuZGVyIGZvcm0gZW52KVxuICAgICAgICAgIDs7IENhbGxpbmcgYSBrZXl3b3JkIGNvbXBpbGVzIHRvIGdldHRpbmcgdmFsdWUgZnJvbSBnaXZlblxuICAgICAgICAgIDs7IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhhdCBrZXk6XG4gICAgICAgICAgOzsgJyg6Zm9vIGJhcikgPT4gJyhnZXQgYmFyIDpmb28pXG4gICAgICAgICAgKGtleXdvcmQ/IG9wKSAoZGVzdWdhciBrZXl3b3JkLWludm9rZSBmb3JtKVxuICAgICAgICAgIDs7ICcoLiBvYmplY3QgbWV0aG9kIGZvbyBiYXIpID0+ICcoKGFnZXQgb2JqZWN0IG1ldGhvZCkgZm9vIGJhcilcbiAgICAgICAgICAoZG90LXN5bnRheD8gb3ApIChkZXN1Z2FyIGRvdC1zeW50YXggZm9ybSlcbiAgICAgICAgICA7OyAnKC4tZmllbGQgb2JqZWN0KSA9PiAnKGFnZXQgb2JqZWN0ICdmaWVsZClcbiAgICAgICAgICAoZmllbGQtc3ludGF4PyBvcCkgKGRlc3VnYXIgZmllbGQtc3ludGF4IGZvcm0pXG4gICAgICAgICAgOzsgJyguc3Vic3RyaW5nIHN0cmluZyAyIDUpID0+ICcoKGFnZXQgc3RyaW5nICdzdWJzdHJpbmcpIDIgNSlcbiAgICAgICAgICAobWV0aG9kLXN5bnRheD8gb3ApIChkZXN1Z2FyIG1ldGhvZC1zeW50YXggZm9ybSlcbiAgICAgICAgICA7OyAnKFBvaW50LiB4IHkpID0+ICcobmV3IFBvaW50IHggeSlcbiAgICAgICAgICAobmV3LXN5bnRheD8gb3ApIChkZXN1Z2FyIG5ldy1zeW50YXggZm9ybSlcbiAgICAgICAgICA6ZWxzZSBmb3JtKSkpXG5cbihkZWZuIG1hY3JvZXhwYW5kXG4gIFwiUmVwZWF0ZWRseSBjYWxscyBtYWNyb2V4cGFuZC0xIG9uIGZvcm0gdW50aWwgaXQgbm8gbG9uZ2VyXG4gIHJlcHJlc2VudHMgYSBtYWNybyBmb3JtLCB0aGVuIHJldHVybnMgaXQuXCJcbiAgW2Zvcm0gZW52XVxuICAobG9vcCBbb3JpZ2luYWwgZm9ybVxuICAgICAgICAgZXhwYW5kZWQgKG1hY3JvZXhwYW5kLTEgZm9ybSBlbnYpXVxuICAgIChpZiAoaWRlbnRpY2FsPyBvcmlnaW5hbCBleHBhbmRlZClcbiAgICAgIG9yaWdpbmFsXG4gICAgICAocmVjdXIgZXhwYW5kZWQgKG1hY3JvZXhwYW5kLTEgZXhwYW5kZWQgZW52KSkpKSlcblxuXG47OyBEZWZpbmUgY29yZSBtYWNyb3NcblxuXG47OyBUT0RPIG1ha2UgdGhpcyBsYW5ndWFnZSBpbmRlcGVuZGVudFxuXG4oZGVmbiBzeW50YXgtcXVvdGUgW2Zvcm1dXG4gIChjb25kIChzeW1ib2w/IGZvcm0pIChsaXN0ICdxdW90ZSBmb3JtKVxuICAgICAgICAoa2V5d29yZD8gZm9ybSkgKGxpc3QgJ3F1b3RlIGZvcm0pXG4gICAgICAgIChvciAobnVtYmVyPyBmb3JtKVxuICAgICAgICAgICAgKHN0cmluZz8gZm9ybSlcbiAgICAgICAgICAgIChib29sZWFuPyBmb3JtKVxuICAgICAgICAgICAgKG5pbD8gZm9ybSlcbiAgICAgICAgICAgIChyZS1wYXR0ZXJuPyBmb3JtKSkgZm9ybVxuXG4gICAgICAgICh1bnF1b3RlPyBmb3JtKSAoc2Vjb25kIGZvcm0pXG4gICAgICAgICh1bnF1b3RlLXNwbGljaW5nPyBmb3JtKSAocmVhZGVyLWVycm9yIFwiSWxsZWdhbCB1c2Ugb2YgYH5AYCBleHByZXNzaW9uLCBjYW4gb25seSBiZSBwcmVzZW50IGluIGEgbGlzdFwiKVxuXG4gICAgICAgIChlbXB0eT8gZm9ybSkgZm9ybVxuXG4gICAgICAgIDs7XG4gICAgICAgIChkaWN0aW9uYXJ5PyBmb3JtKSAobGlzdCAnYXBwbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaWN0aW9uYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29ucyAnLmNvbmNhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlcXVlbmNlLWV4cGFuZCAoYXBwbHkgY29uY2F0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VxIGZvcm0pKSkpKVxuICAgICAgICA7OyBJZiBhIHZlY3RvciBmb3JtIGV4cGFuZCBhbGwgc3ViLWZvcm1zIGFuZCBjb25jYXRlbmF0ZVxuICAgICAgICA7OyB0aGVtIHRvZ2V0aGVyOlxuICAgICAgICA7O1xuICAgICAgICA7OyBbfmEgYiB+QGNdIC0+ICguY29uY2F0IFthXSBbKHF1b3RlIGIpXSBjKVxuICAgICAgICAodmVjdG9yPyBmb3JtKSAoY29ucyAnLmNvbmNhdCAoc2VxdWVuY2UtZXhwYW5kIGZvcm0pKVxuXG4gICAgICAgIDs7IElmIGEgbGlzdCBmb3JtIGV4cGFuZCBhbGwgdGhlIHN1Yi1mb3JtcyBhbmQgYXBwbHlcbiAgICAgICAgOzsgY29uY2F0ZW5hdGlvbiB0byBhIGxpc3QgY29uc3RydWN0b3I6XG4gICAgICAgIDs7XG4gICAgICAgIDs7ICh+YSBiIH5AYykgLT4gKGFwcGx5IGxpc3QgKC5jb25jYXQgW2FdIFsocXVvdGUgYildIGMpKVxuICAgICAgICAobGlzdD8gZm9ybSkgKGlmIChlbXB0eT8gZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgICAgKGNvbnMgJ2xpc3QgbmlsKVxuICAgICAgICAgICAgICAgICAgICAgICAobGlzdCAnYXBwbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnMgJy5jb25jYXQgKHNlcXVlbmNlLWV4cGFuZCBmb3JtKSkpKVxuXG4gICAgICAgIDplbHNlIChyZWFkZXItZXJyb3IgXCJVbmtub3duIENvbGxlY3Rpb24gdHlwZVwiKSkpXG4oZGVmIHN5bnRheC1xdW90ZS1leHBhbmQgc3ludGF4LXF1b3RlKVxuXG4oZGVmbiB1bnF1b3RlLXNwbGljaW5nLWV4cGFuZFxuICBbZm9ybV1cbiAgKGlmICh2ZWN0b3I/IGZvcm0pXG4gICAgZm9ybVxuICAgIChsaXN0ICd2ZWMgZm9ybSkpKVxuXG4oZGVmbiBzZXF1ZW5jZS1leHBhbmRcbiAgXCJUYWtlcyBzZXF1ZW5jZSBvZiBmb3JtcyBhbmQgZXhwYW5kcyB0aGVtOlxuXG4gICgodW5xdW90ZSBhKSkgLT4gKFthXSlcbiAgKCh1bnF1b3RlLXNwbGljaW5nIGEpKSAtPiAoYSlcbiAgKGEpIC0+IChbKHF1b3RlIGIpXSlcbiAgKCh1bnF1b3RlIGEpIGIgKHVucXVvdGUtc3BsaWNpbmcgYSkpIC0+IChbYV0gWyhxdW90ZSBiKV0gYylcIlxuICBbZm9ybXNdXG4gIChtYXAgKGZuIFtmb3JtXVxuICAgICAgICAgKGNvbmQgKHVucXVvdGU/IGZvcm0pIFsoc2Vjb25kIGZvcm0pXVxuICAgICAgICAgICAgICAgKHVucXVvdGUtc3BsaWNpbmc/IGZvcm0pICh1bnF1b3RlLXNwbGljaW5nLWV4cGFuZCAoc2Vjb25kIGZvcm0pKVxuICAgICAgICAgICAgICAgOmVsc2UgWyhzeW50YXgtcXVvdGUtZXhwYW5kIGZvcm0pXSkpXG4gICAgICAgZm9ybXMpKVxuKGluc3RhbGwtbWFjcm8hIDpzeW50YXgtcXVvdGUgc3ludGF4LXF1b3RlLWV4cGFuZClcblxuOzsgVE9ETzogTmV3IHJlYWRlciB0cmFuc2xhdGVzIG5vdD0gY29ycmVjdGx5XG47OyBidXQgZm9yIHRoZSB0aW1lIGJlaW5nIHVzZSBub3QtZXF1YWwgbmFtZVxuKGRlZm4gZXhwYW5kLW5vdC1lcXVhbFxuICBbJiBib2R5XVxuICBgKG5vdCAoPSB+QGJvZHkpKSlcbihpbnN0YWxsLW1hY3JvISA6bm90PSBleHBhbmQtbm90LWVxdWFsKVxuXG4oZGVmbiBleHBhbmQtaWYtbm90XG4gIFwiQ29tcGxlbWVudHMgdGhlIGBpZmAgZXhjbHVzaXZlIGNvbmRpdGlvbmFsIGJyYW5jaC5cIlxuICBbY29uZGl0aW9uIHRydXRoeSBhbHRlcm5hdGl2ZV1cbiAgYChpZiAobm90IH5jb25kaXRpb24pIH50cnV0aHkgfmFsdGVybmF0aXZlKSlcbihpbnN0YWxsLW1hY3JvISA6aWYtbm90IGV4cGFuZC1pZi1ub3QpXG5cbihkZWZuIGV4cGFuZC1jb21tZW50XG4gIFwiSWdub3JlcyBib2R5LCB5aWVsZHMgbmlsXCJcbiAgWyYgYm9keV0pXG4oaW5zdGFsbC1tYWNybyEgOmNvbW1lbnQgZXhwYW5kLWNvbW1lbnQpXG5cbihkZWZuIGV4cGFuZC10aHJlYWQtZmlyc3RcbiAgXCJUaHJlYWQgZmlyc3QgbWFjcm9cIlxuICBbJiBvcGVyYXRpb25zXVxuICAocmVkdWNlXG4gICAgKGZuIFtmb3JtIG9wZXJhdGlvbl1cbiAgICAgIChjb25zIChmaXJzdCBvcGVyYXRpb24pXG4gICAgICAgICAgICAoY29ucyBmb3JtIChyZXN0IG9wZXJhdGlvbikpKSlcbiAgICAoZmlyc3Qgb3BlcmF0aW9ucylcbiAgICAobWFwICMoaWYgKGxpc3Q/ICUpICUgYCh+JSkpXG4gICAgICAgICAocmVzdCBvcGVyYXRpb25zKSkpKVxuKGluc3RhbGwtbWFjcm8hIDotPiBleHBhbmQtdGhyZWFkLWZpcnN0KVxuXG4oZGVmbiBleHBhbmQtdGhyZWFkLWxhc3RcbiAgXCJUaHJlYWQgbGFzdCBtYWNyb1wiXG4gIFsmIG9wZXJhdGlvbnNdXG4gIChyZWR1Y2VcbiAgICAoZm4gW2Zvcm0gb3BlcmF0aW9uXSAoY29uY2F0IG9wZXJhdGlvbiBbZm9ybV0pKVxuICAgIChmaXJzdCBvcGVyYXRpb25zKVxuICAgIChtYXAgIyhpZiAobGlzdD8gJSkgJSBgKH4lKSlcbiAgICAgICAgIChyZXN0IG9wZXJhdGlvbnMpKSkpXG4oaW5zdGFsbC1tYWNybyEgOi0+PiBleHBhbmQtdGhyZWFkLWxhc3QpXG5cbihkZWZuIGV4cGFuZC1kb3RzXG4gIFwiZm9ybSA9PiBmaWVsZE5hbWUtc3ltYm9sIG9yIChpbnN0YW5jZU1ldGhvZE5hbWUtc3ltYm9sIGFyZ3MqKVxuICBFeHBhbmRzIGludG8gYSBtZW1iZXIgYWNjZXNzICguKSBvZiB0aGUgZmlyc3QgbWVtYmVyIG9uIHRoZSBmaXJzdFxuICBhcmd1bWVudCwgZm9sbG93ZWQgYnkgdGhlIG5leHQgbWVtYmVyIG9uIHRoZSByZXN1bHQsIGV0Yy4gRm9yXG4gIGluc3RhbmNlOlxuICAoLi4gZG9jdW1lbnQgLWJvZHkgKGdldC1hdHRyaWJ1dGUgOmNsYXNzKSlcbiAgZXhwYW5kcyB0bzpcbiAgKC4gKC4gZG9jdW1lbnQgLWJvZHkpIGdldC1hdHRyaWJ1dGUgOmNsYXNzKVxuICBidXQgaXMgZWFzaWVyIHRvIHdyaXRlLCByZWFkLCBhbmQgdW5kZXJzdGFuZC5cIlxuICBbeCAmIGZvcm1zXVxuICBgKC0+IH54IH5AKG1hcCAjKGlmIChsaXN0PyAlKSAoY29ucyAnLiAlKSAobGlzdCAnLiAlKSlcbiAgICAgICAgICAgICAgICAgZm9ybXMpKSlcbihpbnN0YWxsLW1hY3JvISA6Li4gZXhwYW5kLWRvdHMpXG5cbihkZWZuIGV4cGFuZC10aHJlYWQtYXNcbiAgXCJCaW5kcyBuYW1lIHRvIGV4cHIsIGV2YWx1YXRlcyB0aGUgZmlyc3QgZm9ybSBpbiB0aGUgbGV4aWNhbCBjb250ZXh0XG4gIG9mIHRoYXQgYmluZGluZywgdGhlbiBiaW5kcyBuYW1lIHRvIHRoYXQgcmVzdWx0LCByZXBlYXRpbmcgZm9yIGVhY2hcbiAgc3VjY2Vzc2l2ZSBmb3JtLCByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBmb3JtLlwiXG4gIFtleHByIG5hbWUgJiBmb3Jtc11cbiAgYChsZXQgW35uYW1lIH5leHByXG4gICAgICAgICB+QChtYXBjYXQgKGZuIFtmb3JtXSBbbmFtZSBmb3JtXSlcbiAgICAgICAgICAgICAgICAgICBmb3JtcyldXG4gICAgIH5uYW1lKSlcbihpbnN0YWxsLW1hY3JvISA6YXMtPiBleHBhbmQtdGhyZWFkLWFzKVxuXG5cbihkZWZuIGV4cGFuZC1jb25kXG4gIFwiVGFrZXMgYSBzZXQgb2YgdGVzdC9leHByIHBhaXJzLiBJdCBldmFsdWF0ZXMgZWFjaCB0ZXN0IG9uZSBhdCBhXG4gIHRpbWUuICBJZiBhIHRlc3QgcmV0dXJucyBsb2dpY2FsIHRydWUsIGNvbmQgZXZhbHVhdGVzIGFuZCByZXR1cm5zXG4gIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBleHByIGFuZCBkb2Vzbid0IGV2YWx1YXRlIGFueSBvZiB0aGVcbiAgb3RoZXIgdGVzdHMgb3IgZXhwcnMuIChjb25kKSByZXR1cm5zIG5pbC5cIlxuICBbJiBjbGF1c2VzXVxuICAoaWYgKG5vdCAoZW1wdHk/IGNsYXVzZXMpKVxuICAgIChsaXN0ICdpZiAoZmlyc3QgY2xhdXNlcylcbiAgICAgICAgICAoaWYgKGVtcHR5PyAocmVzdCBjbGF1c2VzKSlcbiAgICAgICAgICAgICh0aHJvdyAoRXJyb3IgXCJjb25kIHJlcXVpcmVzIGFuIGV2ZW4gbnVtYmVyIG9mIGZvcm1zXCIpKVxuICAgICAgICAgICAgKHNlY29uZCBjbGF1c2VzKSlcbiAgICAgICAgICAoY29ucyAnY29uZCAocmVzdCAocmVzdCBjbGF1c2VzKSkpKSkpXG4oaW5zdGFsbC1tYWNybyEgOmNvbmQgZXhwYW5kLWNvbmQpXG5cbihkZWZuIGV4cGFuZC1jYXNlXG4gIFwiVGFrZXMgYW4gZXhwcmVzc2lvbiwgYW5kIGEgc2V0IG9mIGNsYXVzZXMuXG4gIEVhY2ggY2xhdXNlIGNhbiB0YWtlIHRoZSBmb3JtIG9mIGVpdGhlcjpcblxuICB0ZXN0LWNvbnN0YW50IHJlc3VsdC1leHByXG4gICh0ZXN0LWNvbnN0YW50MSAuLi4gdGVzdC1jb25zdGFudE4pICByZXN1bHQtZXhwclxuXG4gIFRoZSB0ZXN0LWNvbnN0YW50cyBhcmUgbm90IGV2YWx1YXRlZC4gVGhleSBtdXN0IGJlIGNvbXBpbGUtdGltZVxuICBsaXRlcmFscywgYW5kIG5lZWQgbm90IGJlIHF1b3RlZC4gIElmIHRoZSBleHByZXNzaW9uIGlzIGVxdWFsIHRvIGFcbiAgdGVzdC1jb25zdGFudCwgdGhlIGNvcnJlc3BvbmRpbmcgcmVzdWx0LWV4cHIgaXMgcmV0dXJuZWQuIEEgc2luZ2xlXG4gIGRlZmF1bHQgZXhwcmVzc2lvbiBjYW4gZm9sbG93IHRoZSBjbGF1c2VzLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmVcbiAgcmV0dXJuZWQgaWYgbm8gY2xhdXNlIG1hdGNoZXMuIElmIG5vIGRlZmF1bHQgZXhwcmVzc2lvbiBpcyBwcm92aWRlZFxuICBhbmQgbm8gY2xhdXNlIG1hdGNoZXMsIGFuIEVycm9yIGlzIHRocm93bi5cblxuICBVbmxpa2UgY29uZCBhbmQgY29uZHAsIGNhc2UgZG9lcyBhIGNvbnN0YW50LXRpbWUgZGlzcGF0Y2gsIHRoZVxuICBjbGF1c2VzIGFyZSBub3QgY29uc2lkZXJlZCBzZXF1ZW50aWFsbHkuICBBbGwgbWFubmVyIG9mIGNvbnN0YW50XG4gIGV4cHJlc3Npb25zIGFyZSBhY2NlcHRhYmxlIGluIGNhc2UsIGluY2x1ZGluZyBudW1iZXJzLCBzdHJpbmdzLFxuICBzeW1ib2xzLCBrZXl3b3JkcywgYW5kIGNvbXBvc2l0ZXMgdGhlcmVvZi4gTm90ZSB0aGF0IHNpbmNlXG4gIGxpc3RzIGFyZSB1c2VkIHRvIGdyb3VwIG11bHRpcGxlIGNvbnN0YW50cyB0aGF0IG1hcCB0byB0aGUgc2FtZVxuICBleHByZXNzaW9uLCBhIHZlY3RvciBjYW4gYmUgdXNlZCB0byBtYXRjaCBhIGxpc3QgaWYgbmVlZGVkLiBUaGVcbiAgdGVzdC1jb25zdGFudHMgbmVlZCBub3QgYmUgYWxsIG9mIHRoZSBzYW1lIHR5cGUuXG5cbiAgRGVwZW5kcyBvbiA9XCJcbiAgW2UgJiBjbGF1c2VzXVxuICAobGV0IFtzeW0gICAgICAoaWYgKHN5bWJvbD8gZSkgZSAoZ2Vuc3ltIDpjYXNlLWJpbmRpbmcpKVxuICAgICAgICBwYWlycyAgICAocGFydGl0aW9uIDIgY2xhdXNlcylcbiAgICAgICAgZXEqICAgICAgKGZuIFtjXSBgKD0gfnN5bSAnfmMpKVxuICAgICAgICB0YWlsICAgICAoaWYgKG9kZD8gKGNvdW50IGNsYXVzZXMpKVxuICAgICAgICAgICAgICAgICAgIChsYXN0IGNsYXVzZXMpXG4gICAgICAgICAgICAgICAgICAgYCh0aHJvdyAoRXJyb3IgKHN0ciBcIk5vIG1hdGNoaW5nIGNsYXVzZTogXCIgfnN5bSkpKSldXG4gICAgKGxvb3AgW3BhaXJzIHBhaXJzLCBjb25kcyBbXV1cbiAgICAgIChpZiAoZW1wdHk/IHBhaXJzKVxuICAgICAgICAobGV0IFtyZXN1bHQgYChjb25kIH5AY29uZHMgOmVsc2UgfnRhaWwpXVxuICAgICAgICAgIChpZiAoPSBlIHN5bSkgcmVzdWx0IGAobGV0IFt+c3ltIH5lXSB+cmVzdWx0KSkpXG4gICAgICAgIChsZXQgW3ggKGZpcnN0IHBhaXJzKSwgeHMgKHJlc3QgcGFpcnMpLCBjb25zdHMgKGZpcnN0IHgpLCByZXMgKHNlY29uZCB4KV1cbiAgICAgICAgICAocmVjdXIgeHMgKGNvbmogY29uZHMgKGlmLW5vdCAobGlzdD8gY29uc3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcSogY29uc3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAob3IgfkAobWFwIGVxKiBjb25zdHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzKSkpKSkpKVxuKGluc3RhbGwtbWFjcm8hIDpjYXNlIGV4cGFuZC1jYXNlKVxuXG4oZGVmbiBleHBhbmQtY29uZHBcbiAgXCJUYWtlcyBhIGJpbmFyeSBwcmVkaWNhdGUsIGFuIGV4cHJlc3Npb24sIGFuZCBhIHNldCBvZiBjbGF1c2VzLlxuICBFYWNoIGNsYXVzZSBjYW4gdGFrZSB0aGUgZm9ybSBvZiBlaXRoZXI6XG5cbiAgdGVzdC1leHByIHJlc3VsdC1leHByXG4gIHRlc3QtZXhwciA6Pj4gcmVzdWx0LWZuXG5cbiAgTm90ZSA6Pj4gaXMgYW4gb3JkaW5hcnkga2V5d29yZC5cblxuICBGb3IgZWFjaCBjbGF1c2UsIChwcmVkIHRlc3QtZXhwciBleHByKSBpcyBldmFsdWF0ZWQuIElmIGl0IHJldHVybnNcbiAgbG9naWNhbCB0cnVlLCB0aGUgY2xhdXNlIGlzIGEgbWF0Y2guIElmIGEgYmluYXJ5IGNsYXVzZSBtYXRjaGVzLCB0aGVcbiAgcmVzdWx0LWV4cHIgaXMgcmV0dXJuZWQsIGlmIGEgdGVybmFyeSBjbGF1c2UgbWF0Y2hlcywgaXRzIHJlc3VsdC1mbixcbiAgd2hpY2ggbXVzdCBiZSBhIHVuYXJ5IGZ1bmN0aW9uLCBpcyBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZVxuICBwcmVkaWNhdGUgYXMgaXRzIGFyZ3VtZW50LCB0aGUgcmVzdWx0IG9mIHRoYXQgY2FsbCBiZWluZyB0aGUgcmV0dXJuXG4gIHZhbHVlIG9mIGNvbmRwLiBBIHNpbmdsZSBkZWZhdWx0IGV4cHJlc3Npb24gY2FuIGZvbGxvdyB0aGUgY2xhdXNlcyxcbiAgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGlmIG5vIGNsYXVzZSBtYXRjaGVzLiBJZiBubyBkZWZhdWx0XG4gIGV4cHJlc3Npb24gaXMgcHJvdmlkZWQgYW5kIG5vIGNsYXVzZSBtYXRjaGVzLCBhbiBFcnJvciBpcyB0aHJvd24uXCJcbiAgW3ByZWQgZXhwciAmIGNsYXVzZXNdXG4gIChsZXQgW3N5bSogICAgKGdlbnN5bSA6Y29uZHAtYmluZGluZylcbiAgICAgICAgc3ltICAgICAoaWYgKHN5bWJvbD8gZXhwcikgZXhwciBzeW0qKVxuICAgICAgICBjb21wYXJlIChmbiBbeF0gYCh+cHJlZCB+eCB+c3ltKSlcbiAgICAgICAgc3BsaXRzICAoZm4gc3BsaXRzIFt4c11cbiAgICAgICAgICAgICAgICAgIChjb25kIChlbXB0eT8geHMpICAgICAgICAgIGAodGhyb3cgKEVycm9yIChzdHIgXCJObyBtYXRjaGluZyBjbGF1c2U6IFwiIH5zeW0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICg9IDEgKGNvdW50IHhzKSkgICAgIChmaXJzdCB4cylcbiAgICAgICAgICAgICAgICAgICAgICAgICg9ICc6Pj4gKHNlY29uZCB4cykpIGAoaWYtbGV0IFt+c3ltKiB+KGNvbXBhcmUgKGZpcnN0IHhzKSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAofih0aGlyZCB4cykgfnN5bSopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+KHNwbGl0cyAoZHJvcCAzIHhzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6ZWxzZSAgICAgICAgICAgICAgICBgKGlmIH4oY29tcGFyZSAoZmlyc3QgeHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfihzZWNvbmQgeHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+KHNwbGl0cyAoZHJvcCAyIHhzKSkpKSldXG4gICAgKGlmICg9IHN5bSBleHByKVxuICAgICAgKHNwbGl0cyBjbGF1c2VzKVxuICAgICAgYChsZXQgW35zeW0gfmV4cHJdIH4oc3BsaXRzIGNsYXVzZXMpKSkpKVxuKGluc3RhbGwtbWFjcm8hIDpjb25kcCBleHBhbmQtY29uZHApXG5cblxuKGRlZm4tICp0aHJlYWQgW2luc2VydCBzeW0gdGVzdCBmb3JtXVxuICAobGV0IFtmb3JtIChpZiAobGlzdD8gZm9ybSkgZm9ybSAobGlzdCBmb3JtKSldXG4gICAgYChpZiB+dGVzdFxuICAgICAgIH5zeW1cbiAgICAgICB+KGluc2VydCBzeW0gZm9ybSkpKSlcblxuKGRlZm4tICpjb25kLXRocmVhZCBbZXhwciBjbGF1c2VzIGluc2VydF1cbiAgKGxldCBbc3ltIChnZW5zeW0gOmNvbmQtdGhyZWFkLWJpbmRpbmcpXVxuICAgIGAoYXMtPiB+ZXhwciB+c3ltXG4gICAgICAgICAgIH5AKG1hcCAjKCp0aHJlYWQgaW5zZXJ0IHN5bSBgKG5vdCB+KGZpcnN0ICUpKSAoc2Vjb25kICUpKVxuICAgICAgICAgICAgICAgICAgKHBhcnRpdGlvbiAyIGNsYXVzZXMpKSkpKVxuXG4oZGVmbiBleHBhbmQtY29uZC10aHJlYWQtZmlyc3RcbiAgXCJUYWtlcyBhbiBleHByZXNzaW9uIGFuZCBhIHNldCBvZiB0ZXN0L2Zvcm0gcGFpcnMuIFRocmVhZHMgZXhwciAodmlhIC0+KVxuICB0aHJvdWdoIGVhY2ggZm9ybSBmb3Igd2hpY2ggdGhlIGNvcnJlc3BvbmRpbmcgdGVzdFxuICBleHByZXNzaW9uIGlzIHRydWUuIE5vdGUgdGhhdCwgdW5saWtlIGNvbmQgYnJhbmNoaW5nLCBjb25kLT4gdGhyZWFkaW5nIGRvZXNcbiAgbm90IHNob3J0IGNpcmN1aXQgYWZ0ZXIgdGhlIGZpcnN0IHRydWUgdGVzdCBleHByZXNzaW9uLlwiXG4gIFtleHByICYgY2xhdXNlc11cbiAgKCpjb25kLXRocmVhZCBleHByIGNsYXVzZXMgKGZuIFtzeW0gZm9ybV0gKGFwcGx5IGxpc3QgKGZpcnN0IGZvcm0pIHN5bSAodmVjIChyZXN0IGZvcm0pKSkpKSlcbihpbnN0YWxsLW1hY3JvISA6Y29uZC0+IGV4cGFuZC1jb25kLXRocmVhZC1maXJzdClcblxuKGRlZm4gZXhwYW5kLWNvbmQtdGhyZWFkLWxhc3RcbiAgXCJUYWtlcyBhbiBleHByZXNzaW9uIGFuZCBhIHNldCBvZiB0ZXN0L2Zvcm0gcGFpcnMuIFRocmVhZHMgZXhwciAodmlhIC0+PilcbiAgdGhyb3VnaCBlYWNoIGZvcm0gZm9yIHdoaWNoIHRoZSBjb3JyZXNwb25kaW5nIHRlc3QgZXhwcmVzc2lvblxuICBpcyB0cnVlLiAgTm90ZSB0aGF0LCB1bmxpa2UgY29uZCBicmFuY2hpbmcsIGNvbmQtPj4gdGhyZWFkaW5nIGRvZXMgbm90IHNob3J0IGNpcmN1aXRcbiAgYWZ0ZXIgdGhlIGZpcnN0IHRydWUgdGVzdCBleHByZXNzaW9uLlwiXG4gIFtleHByICYgY2xhdXNlc11cbiAgKCpjb25kLXRocmVhZCBleHByIGNsYXVzZXMgKGZuIFtzeW0gZm9ybV0gKGFwcGx5IGxpc3QgKHZlYyAoY29uY2F0IGZvcm0gW3N5bV0pKSkpKSlcbihpbnN0YWxsLW1hY3JvISA6Y29uZC0+PiBleHBhbmQtY29uZC10aHJlYWQtbGFzdClcblxuXG4oZGVmbi0gKnNvbWUtdGhyZWFkIFtleHByIGZvcm1zIGluc2VydF1cbiAgKGxldCBbc3ltIChnZW5zeW0gOnNvbWUtdGhyZWFkLWJpbmRpbmcpXVxuICAgIGAoYXMtPiB+ZXhwciB+c3ltXG4gICAgICAgICAgIH5AKG1hcCAjKCp0aHJlYWQgaW5zZXJ0IHN5bSBgKG5pbD8gfnN5bSkgJSlcbiAgICAgICAgICAgICAgICAgIGZvcm1zKSkpKVxuXG4oZGVmbiBleHBhbmQtc29tZS10aHJlYWQtZmlyc3RcbiAgXCJXaGVuIGV4cHIgaXMgbm90IG5pbCwgdGhyZWFkcyBpdCBpbnRvIHRoZSBmaXJzdCBmb3JtICh2aWEgLT4pLFxuICBhbmQgd2hlbiB0aGF0IHJlc3VsdCBpcyBub3QgbmlsLCB0aHJvdWdoIHRoZSBuZXh0IGV0Y1xuXG4gIERlcGVuZHMgb24gbmlsP1wiXG4gIFtleHByICYgZm9ybXNdXG4gICgqc29tZS10aHJlYWQgZXhwciBmb3JtcyAoZm4gW3N5bSBmb3JtXSAoYXBwbHkgbGlzdCAoZmlyc3QgZm9ybSkgc3ltICh2ZWMgKHJlc3QgZm9ybSkpKSkpKVxuKGluc3RhbGwtbWFjcm8hIDpzb21lLT4gZXhwYW5kLXNvbWUtdGhyZWFkLWZpcnN0KVxuXG4oZGVmbiBleHBhbmQtc29tZS10aHJlYWQtbGFzdFxuICBcIldoZW4gZXhwciBpcyBub3QgbmlsLCB0aHJlYWRzIGl0IGludG8gdGhlIGZpcnN0IGZvcm0gKHZpYSAtPj4pLFxuICBhbmQgd2hlbiB0aGF0IHJlc3VsdCBpcyBub3QgbmlsLCB0aHJvdWdoIHRoZSBuZXh0IGV0Y1xuXG4gIERlcGVuZHMgb24gbmlsP1wiXG4gIFtleHByICYgZm9ybXNdXG4gICgqc29tZS10aHJlYWQgZXhwciBmb3JtcyAoZm4gW3N5bSBmb3JtXSAoYXBwbHkgbGlzdCAodmVjIChjb25jYXQgZm9ybSBbc3ltXSkpKSkpKVxuKGluc3RhbGwtbWFjcm8hIDpzb21lLT4+IGV4cGFuZC1zb21lLXRocmVhZC1sYXN0KVxuXG5cbihkZWZuIGV4cGFuZC1kZWZuXG4gIFwiU2FtZSBhcyAoZGVmIG5hbWUgKGZuIFtwYXJhbXMqIF0gZXhwcnMqKSkgb3JcbiAgKGRlZiBuYW1lIChmbiAoW3BhcmFtcyogXSBleHBycyopKykpIHdpdGggYW55IGRvYy1zdHJpbmcgb3IgYXR0cnMgYWRkZWRcbiAgdG8gdGhlIHZhciBtZXRhZGF0YVwiXG4gIFsmZm9ybSBuYW1lICYgZG9jK21ldGErYm9keV1cbiAgKGxldCBbZG9jIChpZiAoc3RyaW5nPyAoZmlyc3QgZG9jK21ldGErYm9keSkpXG4gICAgICAgICAgICAgIChmaXJzdCBkb2MrbWV0YStib2R5KSlcblxuICAgICAgICA7OyBJZiBkb2NzdHJpbmcgaXMgZm91bmQgaXQncyBub3QgcGFydCBvZiBib2R5LlxuICAgICAgICBtZXRhK2JvZHkgKGlmIGRvYyAocmVzdCBkb2MrbWV0YStib2R5KSBkb2MrbWV0YStib2R5KVxuXG4gICAgICAgIDs7IGRlZm4gbWF5IGNvbnRhaW4gYXR0cmlidXRlIGxpc3QgYWZ0ZXJcbiAgICAgICAgOzsgZG9jc3RyaW5nIG9yIGEgbmFtZSwgaW4gd2hpY2ggY2FzZSBpdCdzXG4gICAgICAgIDs7IG1lcmdlZCBpbnRvIG5hbWUgbWV0YWRhdGEuXG4gICAgICAgIG1ldGFkYXRhIChpZiAoZGljdGlvbmFyeT8gKGZpcnN0IG1ldGErYm9keSkpXG4gICAgICAgICAgICAgICAgICAgKGNvbmogezpkb2MgZG9jfSAoZmlyc3QgbWV0YStib2R5KSkpXG5cbiAgICAgICAgOzsgSWYgbWV0YWRhdGEgbWFwIGlzIGZvdW5kIGl0J3Mgbm90IHBhcnQgb2YgYm9keS5cbiAgICAgICAgYm9keSAoaWYgbWV0YWRhdGEgKHJlc3QgbWV0YStib2R5KSBtZXRhK2JvZHkpXG5cbiAgICAgICAgOzsgQ29tYmluZSBhbGwgdGhlIG1ldGFkYXRhIGFuZCBhZGQgdG8gYSBuYW1lLlxuICAgICAgICBpZCAod2l0aC1tZXRhIG5hbWUgKGNvbmogKG9yIChtZXRhIG5hbWUpIHt9KSBtZXRhZGF0YSkpXG5cbiAgICAgICAgZm4gKHdpdGgtbWV0YSBgKGZuIH5pZCB+QGJvZHkpIChtZXRhICZmb3JtKSldXG4gICAgYChkZWYgfmlkIH5mbikpKVxuKGluc3RhbGwtbWFjcm8hIDpkZWZuICh3aXRoLW1ldGEgZXhwYW5kLWRlZm4gezppbXBsaWNpdCBbOiZmb3JtXX0pKVxuXG5cbihkZWZuIGV4cGFuZC1wcml2YXRlLWRlZm5cbiAgXCJTYW1lIGFzIChkZWYgbmFtZSAoZm4gW3BhcmFtcyogXSBleHBycyopKSBvclxuICAoZGVmIG5hbWUgKGZuIChbcGFyYW1zKiBdIGV4cHJzKikrKSkgd2l0aCBhbnkgZG9jLXN0cmluZyBvciBhdHRycyBhZGRlZFxuICB0byB0aGUgdmFyIG1ldGFkYXRhXCJcbiAgW25hbWUgJiBib2R5XVxuICAobGV0IFttZXRhZGF0YSAoY29uaiAob3IgKG1ldGEgbmFtZSkge30pXG4gICAgICAgICAgICAgICAgICAgICAgIHs6cHJpdmF0ZSB0cnVlfSlcbiAgICAgICAgaWQgKHdpdGgtbWV0YSBuYW1lIG1ldGFkYXRhKV1cbiAgICBgKGRlZm4gfmlkIH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8gOmRlZm4tIGV4cGFuZC1wcml2YXRlLWRlZm4pXG5cblxuKGRlZm4gZXhwYW5kLWxhenktc2VxXG4gIFwiVGFrZXMgYSBib2R5IG9mIGV4cHJlc3Npb25zIHRoYXQgcmV0dXJucyBhbiBJU2VxIG9yIG5pbCwgYW5kIHlpZWxkc1xuICBhIFNlcWFibGUgb2JqZWN0IHRoYXQgd2lsbCBpbnZva2UgdGhlIGJvZHkgb25seSB0aGUgZmlyc3QgdGltZSBzZXFcbiAgaXMgY2FsbGVkLCBhbmQgd2lsbCBjYWNoZSB0aGUgcmVzdWx0IGFuZCByZXR1cm4gaXQgb24gYWxsIHN1YnNlcXVlbnRcbiAgc2VxIGNhbGxzLiBTZWUgYWxzbyAtIHJlYWxpemVkP1xuXG4gIERlcGVuZHMgb24gbGF6eS1zZXFcIlxuICB7OmFkZGVkIFwiMS4wXCJ9XG4gIFsmIGJvZHldXG4gIGAoLmNhbGwgbGF6eS1zZXEgbmlsIGZhbHNlIChmbiBbXSB+QGJvZHkpKSlcbihpbnN0YWxsLW1hY3JvIDpsYXp5LXNlcSBleHBhbmQtbGF6eS1zZXEpXG5cblxuKGRlZm4gZXhwYW5kLXdoZW5cbiAgXCJFdmFsdWF0ZXMgdGVzdC4gSWYgbG9naWNhbCB0cnVlLCBldmFsdWF0ZXMgYm9keSBpbiBhbiBpbXBsaWNpdCBkby5cIlxuICBbdGVzdCAmIGJvZHldXG4gIGAoaWYgfnRlc3QgKGRvIH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8gOndoZW4gZXhwYW5kLXdoZW4pXG5cbihkZWZuIGV4cGFuZC13aGVuLW5vdFxuICBcIkV2YWx1YXRlcyB0ZXN0LiBJZiBsb2dpY2FsIGZhbHNlLCBldmFsdWF0ZXMgYm9keSBpbiBhbiBpbXBsaWNpdCBkby5cIlxuICBbdGVzdCAmIGJvZHldXG4gIGAod2hlbiAobm90IH50ZXN0KSB+QGJvZHkpKVxuKGluc3RhbGwtbWFjcm8gOndoZW4tbm90IGV4cGFuZC13aGVuLW5vdClcblxuXG4oZGVmbiBleHBhbmQtaWYtbGV0XG4gIFwiYmluZGluZ3MgPT4gYmluZGluZy1mb3JtIHRlc3RcbiAgYm9keSA9PiBbdGhlbiBlbHNlXVxuICBJZiB0ZXN0IGlzIHRydWUsIGV2YWx1YXRlcyB0aGVuIHdpdGggYmluZGluZy1mb3JtIGJvdW5kIHRvIHRoZSB2YWx1ZSBvZlxuICB0ZXN0LCBpZiBub3QsIHlpZWxkcyBlbHNlKi5cIlxuICBbYmluZGluZ3MgdGhlbiBlbHNlKl1cbiAgKGxldCBbbmFtZSAoZmlyc3QgYmluZGluZ3MpLCB0ZXN0IChzZWNvbmQgYmluZGluZ3MpLCBzeW0gKGdlbnN5bSA6aWYtbGV0LWJpbmRpbmcpXVxuICAgIGAobGV0IFt+c3ltIH50ZXN0XVxuICAgICAgIChpZiB+c3ltIChsZXQgW35uYW1lIH5zeW1dIH50aGVuKSB+ZWxzZSopKSkpXG4oaW5zdGFsbC1tYWNybyA6aWYtbGV0IGV4cGFuZC1pZi1sZXQpXG5cbihkZWZuIGV4cGFuZC13aGVuLWxldFxuICBcImJpbmRpbmdzID0+IGJpbmRpbmctZm9ybSB0ZXN0XG4gIFdoZW4gdGVzdCBpcyB0cnVlLCBldmFsdWF0ZXMgYm9keSB3aXRoIGJpbmRpbmctZm9ybSBib3VuZCB0byB0aGUgdmFsdWUgb2YgdGVzdC5cIlxuICBbYmluZGluZ3MgJiBib2R5XVxuICBgKGlmLWxldCB+YmluZGluZ3MgKGRvIH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8gOndoZW4tbGV0IGV4cGFuZC13aGVuLWxldClcblxuXG4oZGVmbiBleHBhbmQtaWYtc29tZVxuICBcImJpbmRpbmdzID0+IGJpbmRpbmctZm9ybSB0ZXN0XG4gIElmIHRlc3QgaXMgbm90IG5pbCwgZXZhbHVhdGVzIHRoZW4gd2l0aCBiaW5kaW5nLWZvcm0gYm91bmQgdG8gdGhlXG4gIHZhbHVlIG9mIHRlc3QsIGlmIG5vdCwgeWllbGRzIGVsc2UqLlxuXG4gIERlcGVuZHMgb24gbmlsP1wiXG4gIFtiaW5kaW5ncyB0aGVuIGVsc2UqXVxuICAobGV0IFtuYW1lIChmaXJzdCBiaW5kaW5ncyksIHRlc3QgKHNlY29uZCBiaW5kaW5ncyksIHN5bSAoaWYgKHN5bWJvbD8gbmFtZSkgbmFtZSAoZ2Vuc3ltIDppZi1zb21lLWJpbmRpbmcpKV1cbiAgICBgKGxldCBbfnN5bSB+dGVzdF1cbiAgICAgICAoaWYtbm90IChuaWw/IH5zeW0pXG4gICAgICAgICAobGV0IFt+bmFtZSB+c3ltXSB+dGhlbilcbiAgICAgICAgIH5lbHNlKikpKSlcbihpbnN0YWxsLW1hY3JvIDppZi1zb21lIGV4cGFuZC1pZi1zb21lKVxuXG4oZGVmbiBleHBhbmQtd2hlbi1zb21lXG4gIFwiYmluZGluZ3MgPT4gYmluZGluZy1mb3JtIHRlc3RcbiAgV2hlbiB0ZXN0IGlzIG5vdCBuaWwsIGV2YWx1YXRlcyBib2R5IHdpdGggYmluZGluZy1mb3JtIGJvdW5kIHRvIHRoZVxuICB2YWx1ZSBvZiB0ZXN0LlwiXG4gIFtiaW5kaW5ncyAmIGJvZHldXG4gIGAoaWYtc29tZSB+YmluZGluZ3MgKGRvIH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8gOndoZW4tc29tZSBleHBhbmQtd2hlbi1zb21lKVxuXG5cbihkZWZuIGV4cGFuZC13aGVuLWZpcnN0XG4gIFwiYmluZGluZ3MgPT4geCB4c1xuICBSb3VnaGx5IHRoZSBzYW1lIGFzICh3aGVuIChzZXEgeHMpIChsZXQgW3ggKGZpcnN0IHhzKV0gYm9keSkpIGJ1dCB4cyBpcyBldmFsdWF0ZWQgb25seSBvbmNlXG5cbiAgRGVwZW5kcyBvbiBzZXEqXCJcbiAgW2JpbmRpbmdzICYgYm9keV1cbiAgKGxldCBbbmFtZSAoZmlyc3QgYmluZGluZ3MpLCB0ZXN0IChzZWNvbmQgYmluZGluZ3MpXVxuICAgIGAod2hlbi1sZXQgW1t+bmFtZV0gKHNlcSogfnRlc3QpXSB+QGJvZHkpKSlcbihpbnN0YWxsLW1hY3JvIDp3aGVuLWZpcnN0IGV4cGFuZC13aGVuLWZpcnN0KVxuXG5cbihkZWZuIGV4cGFuZC13aGlsZVxuICBcIlJlcGVhdGVkbHkgZXhlY3V0ZXMgYm9keSB3aGlsZSB0ZXN0IGV4cHJlc3Npb24gaXMgdHJ1ZS4gUHJlc3VtZXNcbiAgc29tZSBzaWRlLWVmZmVjdCB3aWxsIGNhdXNlIHRlc3QgdG8gYmVjb21lIGZhbHNlL25pbC4gUmV0dXJucyBuaWxcIlxuICBbdGVzdCAmIGJvZHldXG4gIGAobG9vcCBbXVxuICAgICAod2hlbiB+dGVzdCB+QGJvZHkgKHJlY3VyKSkpKVxuKGluc3RhbGwtbWFjcm8gOndoaWxlIGV4cGFuZC13aGlsZSlcblxuXG4oZGVmbiBleHBhbmQtZG90b1xuICBcIkV2YWx1YXRlcyB4IHRoZW4gY2FsbHMgYWxsIG9mIHRoZSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgd2l0aCB0aGVcbiAgdmFsdWUgb2YgeCBzdXBwbGllZCBhdCB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIGFyZ3VtZW50cy4gIFRoZSBmb3Jtc1xuICBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLiAgUmV0dXJucyB4LlxuICAoZG90byAoTWFwLikgKC5zZXQgOmEgMSkgKC5zZXQgOmIgMikpXCJcbiAgW3ggJiBmb3Jtc11cbiAgKGxldCBbc3ltIChnZW5zeW0gOmRvdG8tYmluZGluZyldXG4gICAgYChsZXQgW35zeW0gfnhdXG4gICAgICAgfkAobWFwICMoY29uY2F0IFsoZmlyc3QgJSkgc3ltXSAocmVzdCAlKSkgZm9ybXMpXG4gICAgICAgfnN5bSkpKVxuKGluc3RhbGwtbWFjcm8gOmRvdG8gZXhwYW5kLWRvdG8pXG5cbihkZWZuIGV4cGFuZC1kb3RpbWVzXG4gIFwiYmluZGluZ3MgPT4gbmFtZSBuXG4gIFJlcGVhdGVkbHkgZXhlY3V0ZXMgYm9keSAocHJlc3VtYWJseSBmb3Igc2lkZS1lZmZlY3RzKSB3aXRoIG5hbWVcbiAgYm91bmQgdG8gaW50ZWdlcnMgZnJvbSAwIHRocm91Z2ggbi0xLlwiXG4gIFtiaW5kaW5ncyAmIGJvZHldXG4gIChsZXQgW25hbWUgKGZpcnN0IGJpbmRpbmdzKSwgIG4gKHNlY29uZCBiaW5kaW5ncyksICBzeW0gKGdlbnN5bSA6ZG90aW1lcy1iaW5kaW5nKV1cbiAgICBgKGxldCBbfnN5bSB+bl1cbiAgICAgICAobG9vcCBbfm5hbWUgMF1cbiAgICAgICAgICh3aGVuICg8IH5uYW1lIH5zeW0pXG4gICAgICAgICAgIH5AYm9keVxuICAgICAgICAgICAocmVjdXIgKGluYyB+bmFtZSkpKSkpKSlcbihpbnN0YWxsLW1hY3JvIDpkb3RpbWVzIGV4cGFuZC1kb3RpbWVzKVxuXG5cbihkZWZuLSBmb3Itc3RlcCBbY29udGV4dCBsb29wICYgbW9kaWZpZXJzXVxuICAobGV0IFtpdGVyICAoOml0ZXIgY29udGV4dCksICBjb2xsICg6Y29sbCBjb250ZXh0KSwgIGJvZHkgKDpib2R5IGNvbnRleHQpLCAgc3Vic2VxICg6c3Vic2VxIGNvbnRleHQpXG4gICAgICAgIGJvZHkqIChpZi1ub3Qgc3Vic2VxIGJvZHkgYChsZXQgW35zdWJzZXEgfmJvZHldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChlbXB0eT8gfnN1YnNlcSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWN1ciAocmVzdCB+Y29sbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobGF6eS1jb25jYXQgfnN1YnNlcSAofml0ZXIgKHJlc3QgfmNvbGwpKSkpKSlcbiAgICAgICAgbmV4dCAgKGxvb3AgW21vZHMgKHJldmVyc2UgbW9kaWZpZXJzKSwgYm9keSBib2R5Kl1cbiAgICAgICAgICAgICAgICAoaWYgKGVtcHR5PyBtb2RzKVxuICAgICAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgICAgICAgKGxldCBbbSAoZmlyc3QgbW9kcyksICBpdGVtIChmaXJzdCBtKSwgIGFyZyAoc2Vjb25kIG0pXVxuICAgICAgICAgICAgICAgICAgICAocmVjdXIgKHJlc3QgbW9kcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25kICg9IGl0ZW0gJzpsZXQpICAgYChsZXQgfmFyZyB+Ym9keSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg9IGl0ZW0gJzp3aGlsZSkgYChpZiB+YXJnIH5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKD0gaXRlbSAnOndoZW4pICBgKGlmIH5hcmcgfmJvZHkgKHJlY3VyIChyZXN0IH5jb2xsKSkpKSkpKSldXG4gICAgKG1lcmdlIGNvbnRleHRcbiAgICAgICAgICAgezpzdWJzZXEgKGdlbnN5bSA6Zm9yLXN1YnNlcSlcbiAgICAgICAgICAgIDpib2R5ICAgYCgoZm4gfml0ZXIgW35jb2xsXVxuICAgICAgICAgICAgICAgICAgICAgICAgKGxhenktc2VxIChsb29wIFt+Y29sbCB+Y29sbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZi1ub3QgKGVtcHR5PyB+Y29sbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxldCBbfihmaXJzdCBsb29wKSAoZmlyc3QgfmNvbGwpXSB+bmV4dCkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgfihzZWNvbmQgbG9vcCkpfSkpKVxuXG4oZGVmIF46cHJpdmF0ZSBmb3ItbW9kaWZpZXJzICN7JzpsZXQgJzp3aGlsZSAnOndoZW59KVxuXG4oZGVmbi0gZm9yLXBhcnRzIFtzZXEtZXhwci1wYWlyc11cbiAgKGxldCBbbiAgICAgICAgKGNvdW50IHNlcS1leHByLXBhaXJzKVxuICAgICAgICBpbmRpY2VzICAoZmlsdGVyICMoLT4gKGFnZXQgc2VxLWV4cHItcGFpcnMgJSkgZmlyc3QgZm9yLW1vZGlmaWVycyBub3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgKHJhbmdlIG4pKVxuICAgICAgICBzZWdtZW50cyAocGFydGl0aW9uIDIgMSAoY29uaiBpbmRpY2VzIG4pKV1cbiAgICAobWFwICMoLnNsaWNlIHNlcS1leHByLXBhaXJzIChmaXJzdCAlKSAoc2Vjb25kICUpKVxuICAgICAgICAgc2VnbWVudHMpKSlcblxuKGRlZm4gZXhwYW5kLWZvclxuICBcIkxpc3QgY29tcHJlaGVuc2lvbi4gVGFrZXMgYSB2ZWN0b3Igb2Ygb25lIG9yIG1vcmVcbiAgIGJpbmRpbmctZm9ybS9jb2xsZWN0aW9uLWV4cHIgcGFpcnMsIGVhY2ggZm9sbG93ZWQgYnkgemVybyBvciBtb3JlXG4gICBtb2RpZmllcnMsIGFuZCB5aWVsZHMgYSBsYXp5IHNlcXVlbmNlIG9mIGV2YWx1YXRpb25zIG9mIGV4cHIuXG4gICBDb2xsZWN0aW9ucyBhcmUgaXRlcmF0ZWQgaW4gYSBuZXN0ZWQgZmFzaGlvbiwgcmlnaHRtb3N0IGZhc3Rlc3QsXG4gICBhbmQgbmVzdGVkIGNvbGwtZXhwcnMgY2FuIHJlZmVyIHRvIGJpbmRpbmdzIGNyZWF0ZWQgaW4gcHJpb3JcbiAgIGJpbmRpbmctZm9ybXMuICBTdXBwb3J0ZWQgbW9kaWZpZXJzIGFyZTogOmxldCBbYmluZGluZy1mb3JtIGV4cHIgLi4uXSxcbiAgIDp3aGlsZSB0ZXN0LCA6d2hlbiB0ZXN0LlxuICAodGFrZSAxMDAgKGZvciBbeCAoaW5maW5pdGUtcmFuZ2UpLCB5IChpbmZpbml0ZS1yYW5nZSksIDp3aGlsZSAoPCB5IHgpXSAgW3ggeV0pKVxuXG4gIERlcGVuZHMgb24gbGF6eS1zZXEsIGxhenktY29uY2F0LCBlbXB0eT8sIGZpcnN0LCByZXN0LCBjb25zXCJcbiAgW3NlcS1leHBycyBib2R5LWV4cHJdXG4gIChsZXQgW2l0ZXIgKGdlbnN5bSA6Zm9yLWl0ZXIpLCBjb2xsIChnZW5zeW0gOmZvci1jb2xsKSwgcGFydHMgKGZvci1wYXJ0cyAocGFydGl0aW9uIDIgc2VxLWV4cHJzKSldXG4gICAgKDpib2R5IChyZWR1Y2UgIyhhcHBseSBmb3Itc3RlcCAlMSAlMilcbiAgICAgICAgICAgICAgICAgICB7Oml0ZXIgaXRlciwgOmNvbGwgY29sbCwgOmJvZHkgYChjb25zIH5ib2R5LWV4cHIgKH5pdGVyIChyZXN0IH5jb2xsKSkpfVxuICAgICAgICAgICAgICAgICAgIChyZXZlcnNlIHBhcnRzKSkpKSlcbihpbnN0YWxsLW1hY3JvIDpmb3IgZXhwYW5kLWZvcilcblxuKGRlZm4gZXhwYW5kLWRvc2VxXG4gIFwiUmVwZWF0ZWRseSBleGVjdXRlcyBib2R5IChwcmVzdW1hYmx5IGZvciBzaWRlLWVmZmVjdHMpIHdpdGhcbiAgYmluZGluZ3MgYW5kIGZpbHRlcmluZyBhcyBwcm92aWRlZCBieSAnZm9yJy4gRG9lcyBub3QgcmV0YWluXG4gIHRoZSBoZWFkIG9mIHRoZSBzZXF1ZW5jZS4gUmV0dXJucyBuaWwuXG5cbiAgRGVwZW5kcyBvbiBsYXp5LXNlcSwgbGF6eS1jb25jYXQsIGVtcHR5PywgZmlyc3QsIHJlc3QsIGNvbnMsIGRvcnVuXCJcbiAgW3NlcS1leHBycyAmIGJvZHldXG4gIGAoZG9ydW4gKGZvciB+c2VxLWV4cHJzIChkbyB+QGJvZHkgbmlsKSkpKVxuKGluc3RhbGwtbWFjcm8gOmRvc2VxIGV4cGFuZC1kb3NlcSlcblxuXG4oZGVmbi0gc3ltKiBbc3RyaW5nXVxuICAobGV0IFt3b3JkcyAoc3BsaXQgKG5hbWUgc3RyaW5nKSAjXCItXCIpXVxuICAgIChqb2luIChjb25zIChmaXJzdCB3b3JkcykgKG1hcCBjYXBpdGFsaXplIChyZXN0IHdvcmRzKSkpKSkpXG4oZGVmbi0gYmluZC1zeW0qIFtzIGJdXG4gIChhc3NlcnQgKHN5bWJvbD8gcykgXCJFeHBlY3RlZCBhIHN5bWJvbCBoZXJlIVwiKVxuICBbcyBiXSlcbihkZWZuLSBjb25qLXN5bXMqIFtnZXQqIHJlc3VsdCBrIHYgZiBxdW90ZV1cbiAgKGxldCBbay1ucyAobmFtZXNwYWNlIGspLCBnICMoZiBrLW5zIChuYW1lICUpKV1cbiAgICAodmVjIChjb25jYXQgcmVzdWx0IChtYXBjYXQgIyhiaW5kLXN5bSogJSAoZ2V0KiAlIChnICUpIHF1b3RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdikpKSkpXG4oZGVmbi0gZGljdC1nZXQqIFtkaWN0LW5hbWUgZGVmYXVsdHNdXG4gIChmbiBbYmluZGluZyBrZXkgcXVvdGVdXG4gICAgKGxldCBbcyAobmFtZSBrZXkpXG4gICAgICAgICAgayAoa2V5d29yZCAobmFtZXNwYWNlIGtleSkgKGlmIChzeW1ib2w/IGtleSkgKHN5bSogcykgcykpXVxuICAgICAgYChnZXQgfmRpY3QtbmFtZSB+KGlmLW5vdCBxdW90ZSBrIGAnfmspIH4oYW5kIGJpbmRpbmcgKGFnZXQgZGVmYXVsdHMgYmluZGluZykpKSkpKVxuXG4oZGVmbiBkZXN0cnVjdHVyZS1kaWN0IFtiaW5kaW5nIGZyb21dXG4gIChsZXQgW2RpY3QtbmFtZSAgKG9yIChhZ2V0IGJpbmRpbmcgJzphcykgKGdlbnN5bSA6ZGVzdHJ1Y3R1cmUtYmluZCkpXG4gICAgICAgIGRpY3QtYmluZCAgYChpZiAoZGljdGlvbmFyeT8gfmRpY3QtbmFtZSkgfmRpY3QtbmFtZSAoYXBwbHkgZGljdGlvbmFyeSAodmVjIH5kaWN0LW5hbWUpKSlcbiAgICAgICAgZ2V0KiAgICAgICAoZGljdC1nZXQqIGRpY3QtbmFtZSAoZ2V0IGJpbmRpbmcgJzpvciB7fSkpXVxuICAgIChsb29wIFtrcyAoa2V5cyAoZGlzc29jIGJpbmRpbmcgJzphcyAnOm9yKSksIHJlc3VsdCBbZGljdC1uYW1lIGZyb20sIGRpY3QtbmFtZSBkaWN0LWJpbmRdXVxuICAgICAgKGlmIChlbXB0eT8ga3MpXG4gICAgICAgIHJlc3VsdFxuICAgICAgICAobGV0IFtrIChmaXJzdCBrcyksIHYgKGdldCBiaW5kaW5nIGspLCBrKiAoYW5kIChrZXl3b3JkPyBrKSAobmFtZSBrKSldXG4gICAgICAgICAgKGFzc2VydCAob3IgKHN5bWJvbD8gaykgKGFuZCBrKiAoI3s6a2V5cyA6c3RycyA6c3ltc30gayopKSlcbiAgICAgICAgICAgICAgICAgIChzdHIgXCJJbnZhbGlkIGRlc3RydWN0dXJlIGtleSBcIiBrKSlcbiAgICAgICAgICAocmVjdXIgKHJlc3Qga3MpIChjb25kICg9IGsqIDpzdHJzKSAoY29uai1zeW1zKiBnZXQqIHJlc3VsdCBrIHYga2V5d29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg9IGsqIDpzeW1zKSAoY29uai1zeW1zKiBnZXQqIHJlc3VsdCBrIHYgIyhzeW1ib2wgJTEgKHN5bSogJTIpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg9IGsqIDprZXlzKSAoY29uai1zeW1zKiBnZXQqIHJlc3VsdCBrIHYga2V5d29yZCA6cXVvdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVtYmVyPyB2KSAgKGNvbmogcmVzdWx0IGsgKGdldCogayAoc3ltYm9sIChzdHIgdikpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbHNlICAgICAgICAoY29uaiByZXN1bHQgayAoZ2V0KiBrIHYpKSkpKSkpKSlcblxuKGRlZm4gZGVzdHJ1Y3R1cmUtc2VxIFtiaW5kaW5nIGZyb21dXG4gIChsZXQgW2FzICAgICAgICguZmluZC1pbmRleCBiaW5kaW5nICMoPSAlICc6YXMpKVxuICAgICAgICBzZXEtbmFtZSAoaWYgKDwgYXMgMCkgKGdlbnN5bSA6ZGVzdHJ1Y3R1cmUtYmluZCkgKG50aCBiaW5kaW5nIChpbmMgYXMpKSlcbiAgICAgICAgYmluZGluZzEgKGlmICg8IGFzIDApIGJpbmRpbmcgKHRha2UgYXMgYmluZGluZykpXG4gICAgICAgIG1vcmUgICAgICguZmluZC1pbmRleCBiaW5kaW5nMSAjKD0gJSAnJikpXG4gICAgICAgIHRhaWwgICAgIChpZiAoPj0gbW9yZSAwKSAobnRoIGJpbmRpbmcxIChpbmMgbW9yZSkpKVxuICAgICAgICBiaW5kaW5nMiAoaWYgKDwgbW9yZSAwKSBiaW5kaW5nMSAodGFrZSBtb3JlIGJpbmRpbmcpKV1cbiAgICAoYXNzZXJ0IChvciAoPCBhcyAwKSAoPSBhcyAoLSAoY291bnQgYmluZGluZykgMikpKVxuICAgICAgICAgICAgXCJpbnZhbGlkIDphcyBpbiBzZXEtZGVzdHJ1Y3R1cmluZ1wiKVxuICAgIChhc3NlcnQgKG9yICg8IG1vcmUgMCkgKD0gbW9yZSAoLSAoY291bnQgYmluZGluZzEpIDIpKSlcbiAgICAgICAgICAgIFwiaW52YWxpZCAmIGluIHNlcS1kZXN0cnVjdHVyaW5nXCIpXG4gICAgKGxvb3AgW3hzIGJpbmRpbmcyLCBpIDAsIHJlc3VsdCBbc2VxLW5hbWUgZnJvbV1dXG4gICAgICAobGV0IFt4IChmaXJzdCB4cyldXG4gICAgICAgIChjb25kIChlbXB0eT8geHMpIChpZi1ub3QgdGFpbCByZXN1bHQgKGNvbmogcmVzdWx0IHRhaWwgYChkcm9wIH5tb3JlIH5zZXEtbmFtZSkpKVxuICAgICAgICAgICAgICAoPSB4ICdfKSAgICAocmVjdXIgKHJlc3QgeHMpIChpbmMgaSkgcmVzdWx0KVxuICAgICAgICAgICAgICA6ZWxzZSAgICAgICAocmVjdXIgKHJlc3QgeHMpIChpbmMgaSkgKGNvbmogcmVzdWx0IHggYChudGggfnNlcS1uYW1lIH5pKSkpKSkpKSlcblxuKGRlZm4gZGVzdHJ1Y3R1cmUgW2JpbmRpbmdzXVxuICAobGV0IFtwYWlycyAocGFydGl0aW9uIDIgYmluZGluZ3MpXVxuICAgIChpZiAoZXZlcnk/ICMoc3ltYm9sPyAoZmlyc3QgJSkpIHBhaXJzKVxuICAgICAgYmluZGluZ3NcbiAgICAgIChkZXN0cnVjdHVyZSAodmVjIChtYXBjYXQgIyhjb25kICh2ZWN0b3I/ICAgICAoZmlyc3QgJSkpIChhcHBseSBkZXN0cnVjdHVyZS1zZXEgJSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWN0aW9uYXJ5PyAoZmlyc3QgJSkpIChhcHBseSBkZXN0cnVjdHVyZS1kaWN0ICUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ltYm9sPyAgICAgKGZpcnN0ICUpKSAlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZWxzZSAgICAgICAgICAgICAgICAgICAodGhyb3cgXCJJbnZhbGlkIGJpbmRpbmdcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJzKSkpKSkpXG5cbihkZWZuLSBiaW5kLW5hbWVzKiBba2V5c11cbiAgKHppcG1hcCBrZXlzIChyZXBlYXRlZGx5IChjb3VudCBrZXlzKSAjKGdlbnN5bSA6ZGVzdHJ1Y3R1cmUtYmluZCkpKSlcbihkZWZuLSBiaW5kLWluZGljZXMqIFtuYW1lc11cbiAgKGZpbHRlciAjKG5vdCAoc3ltYm9sPyAobnRoIG5hbWVzICUpKSkgKHJhbmdlIChjb3VudCBuYW1lcykpKSlcblxuKGRlZm4gZXhwYW5kLWxldFxuICBcImJpbmRpbmcgPT4gYmluZGluZy1mb3JtIGluaXQtZXhwclxuXG4gIEV2YWx1YXRlcyB0aGUgZXhwcnMgaW4gYSBsZXhpY2FsIGNvbnRleHQgaW4gd2hpY2ggdGhlIHN5bWJvbHMgaW5cbiAgdGhlIGJpbmRpbmctZm9ybXMgYXJlIGJvdW5kIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW5pdC1leHBycyBvciBwYXJ0c1xuICB0aGVyZWluLlxuXG4gIERlcGVuZHMgb24gZGljdGlvbmFyeT8sIGRpY3Rpb25hcnksIHZlYywgZ2V0XCJcbiAgW2JpbmRpbmdzICYgYm9keV1cbiAgYChsZXQqIH4oZGVzdHJ1Y3R1cmUgYmluZGluZ3MpIH5AYm9keSkpXG4oaW5zdGFsbC1tYWNybyA6bGV0IGV4cGFuZC1sZXQpXG5cbihkZWZuIGV4cGFuZC1mblxuICBcIihmbiBuYW1lPyBbcGFyYW1zKl0gZXhwcnMqKVxuICAgKGZuIG5hbWU/IChbcGFyYW1zKl0gZXhwcnMqKSArKVxuXG4gIHBhcmFtcyA9PiBwb3NpdGlvbmFsLXBhcmFtcyogLCBvciBwb3NpdGlvbmFsLXBhcmFtcyogJiBuZXh0LXBhcmFtXG4gIHBvc2l0aW9uYWwtcGFyYW0gPT4gYmluZGluZy1mb3JtXG4gIG5leHQtcGFyYW0gPT4gYmluZGluZy1mb3JtXG4gIG5hbWUgPT4gc3ltYm9sXG5cbiAgRGVmaW5lcyBhIGZ1bmN0aW9uXG5cbiAgRGVwZW5kcyBvbiBkaWN0aW9uYXJ5PywgZGljdGlvbmFyeSwgdmVjLCBnZXRcIlxuICBbJiBhcmdzXVxuICAobGV0IFtuYW1lIChpZiAoc3ltYm9sPyAoZmlyc3QgYXJncykpIChmaXJzdCBhcmdzKSlcbiAgICAgICAgZGVmcyAoaWYgbmFtZSAocmVzdCBhcmdzKSBhcmdzKVxuICAgICAgICBta2ZuICMoaWYgbmFtZSBgKGZuKiB+bmFtZSB+QCUpIGAoZm4qIH5AJSkpXG4gICAgICAgIGRlZiogKGZuIFthcmdzICYgYm9keV1cbiAgICAgICAgICAgICAgIChsZXQgW2luZGljZXMgKGJpbmQtaW5kaWNlcyogYXJncyksIG5hbWVzIChiaW5kLW5hbWVzKiBpbmRpY2VzKV1cbiAgICAgICAgICAgICAgICAgKGlmIChlbXB0eT8gbmFtZXMpXG4gICAgICAgICAgICAgICAgICAgKGNvbnMgYXJncyBib2R5KVxuICAgICAgICAgICAgICAgICAgIGAofih2ZWMgKG1hcC1pbmRleGVkICMoZ2V0IG5hbWVzICUxICUyKSBhcmdzKSlcbiAgICAgICAgICAgICAgICAgICAgICAobGV0IH4odmVjIChtYXBjYXQgKGZuIFtpXSBbKGFnZXQgYXJncyBpKSAoYWdldCBuYW1lcyBpKV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfkBib2R5KSkpKSldXG4gICAgKGlmICh2ZWN0b3I/IChmaXJzdCBkZWZzKSlcbiAgICAgIChta2ZuIChhcHBseSBkZWYqIGRlZnMpKVxuICAgICAgKG1rZm4gKG1hcCAjKGFwcGx5IGRlZiogKHZlYyAlKSkgZGVmcykpKSkpXG4oaW5zdGFsbC1tYWNybyA6Zm4gZXhwYW5kLWZuKVxuXG4oZGVmbiBleHBhbmQtbG9vcFxuICBcIkV2YWx1YXRlcyB0aGUgZXhwcnMgaW4gYSBsZXhpY2FsIGNvbnRleHQgaW4gd2hpY2ggdGhlIHN5bWJvbHMgaW5cbiAgdGhlIGJpbmRpbmctZm9ybXMgYXJlIGJvdW5kIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW5pdC1leHBycyBvciBwYXJ0c1xuICB0aGVyZWluLiBBY3RzIGFzIGEgcmVjdXIgdGFyZ2V0LlxuXG4gIERlcGVuZHMgb24gZGljdGlvbmFyeT8sIGRpY3Rpb25hcnksIHZlYywgZ2V0XCJcbiAgW2JpbmRpbmdzICYgYm9keV1cbiAgKGxldCBbcGFpcnMgICAocGFydGl0aW9uIDIgYmluZGluZ3MpXG4gICAgICAgIGluZGljZXMgKGJpbmQtaW5kaWNlcyogKG1hcHYgZmlyc3QgcGFpcnMpKVxuICAgICAgICBuYW1lcyAgIChiaW5kLW5hbWVzKiBpbmRpY2VzKVxuICAgICAgICBnZXQqICAgICMoaWYtbGV0IFt4IChhZ2V0IG5hbWVzICUxKV1cbiAgICAgICAgICAgICAgICAgICBbeCAoc2Vjb25kICUyKSAoZmlyc3QgJTIpIHhdXG4gICAgICAgICAgICAgICAgICAgJTIpXVxuICAgIChpZiAoZW1wdHk/IG5hbWVzKVxuICAgICAgYChsb29wKiB+YmluZGluZ3MgfkBib2R5KVxuICAgICAgYChsZXQgfih2ZWMgKGFwcGx5IGNvbmNhdCAobWFwLWluZGV4ZWQgZ2V0KiBwYWlycykpKVxuICAgICAgICAgKGxvb3AqIH4odmVjIChhcHBseSBjb25jYXQgKG1hcC1pbmRleGVkICMobGV0IFt4IChnZXQgbmFtZXMgJTEgKGZpcnN0ICUyKSldIFt4IHhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJzKSkpXG4gICAgICAgICAgIChsZXQgfih2ZWMgKG1hcGNhdCAoZm4gW2ldIFsoZmlyc3QgKGFnZXQgcGFpcnMgaSkpIChhZ2V0IG5hbWVzIGkpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMpKVxuICAgICAgICAgICAgIH5AYm9keSkpKSkpKVxuKGluc3RhbGwtbWFjcm8gOmxvb3AgZXhwYW5kLWxvb3ApXG4iXX0=
