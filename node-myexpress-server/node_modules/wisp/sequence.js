{
    var _ns_ = {
            id: 'wisp.sequence',
            doc: void 0
        };
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isVector = wisp_runtime.isVector;
    var isFn = wisp_runtime.isFn;
    var isNumber = wisp_runtime.isNumber;
    var isString = wisp_runtime.isString;
    var isDictionary = wisp_runtime.isDictionary;
    var isSet = wisp_runtime.isSet;
    var keyValues = wisp_runtime.keyValues;
    var str = wisp_runtime.str;
    var int = wisp_runtime.int;
    var dec = wisp_runtime.dec;
    var inc = wisp_runtime.inc;
    var min = wisp_runtime.min;
    var merge = wisp_runtime.merge;
    var dictionary = wisp_runtime.dictionary;
    var get = wisp_runtime.get;
    var isIterable = wisp_runtime.isIterable;
    var isEqual = wisp_runtime.isEqual;
    var complement = wisp_runtime.complement;
    var identity = wisp_runtime.identity;
    var isList = wisp_runtime.isList;
    var isLazySeq = wisp_runtime.isLazySeq;
    var isIdentitySet = wisp_runtime.isIdentitySet;
}
var _wispTypes = isEqual._wispTypes;
var listIterator = function listIterator() {
    return function () {
        var selfø1 = this;
        return {
            'next': function () {
                return isEmpty(selfø1) ? { 'done': true } : function () {
                    var xø1 = first(selfø1);
                    selfø1 = rest(selfø1);
                    return { 'value': xø1 };
                }.call(this);
            }
        };
    }.call(this);
};
var seqToString = function seqToString(lparen, rparen) {
    return function () {
        return function loop() {
            var recur = loop;
            var listø1 = this;
            var resultø1 = '';
            do {
                recur = isEmpty(listø1) ? '' + lparen + resultø1.substr(1) + rparen : (loop[0] = rest(listø1), loop[1] = '' + resultø1 + ' ' + function () {
                    var xø1 = first(listø1);
                    return isVector(xø1) ? '' + '[' + xø1.join(' ') + ']' : isNil(xø1) ? 'nil' : isString(xø1) ? JSON.stringify(xø1) : isNumber(xø1) ? JSON.stringify(xø1) : 'else' ? xø1 : void 0;
                }.call(this), loop);
            } while (listø1 = loop[0], resultø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
};
var List = function List(head, tail) {
    this.head = head;
    this.tail = tail || list();
    this.length = isNil(this.tail) || isDictionary(this.tail) || isNumber(this.tail.length) ? inc(count(this.tail)) : void 0;
    return this;
};
List.prototype.length = 0;
List.type = (_wispTypes || 0)['list'];
List.prototype.type = List.type;
List.prototype.tail = Object.create(List.prototype);
List.prototype.toString = seqToString('(', ')');
List.prototype[Symbol.iterator] = listIterator;
var lazySeqValue = function lazySeqValue(lazySeq) {
    return lazySeq.realized ? lazySeq.x : function () {
        var xø1 = lazySeq.x();
        lazySeq.realized = true;
        isEmpty(xø1) ? lazySeq.length = 0 : void 0;
        return lazySeq.x = xø1;
    }.call(this);
};
var LazySeq = function LazySeq(realized, x) {
    this.realized = realized || false;
    this.x = x;
    return this;
};
LazySeq.type = (_wispTypes || 0)['lazy-seq'];
LazySeq.prototype.type = LazySeq.type;
LazySeq.prototype[Symbol.iterator] = listIterator;
var lazySeq = exports.lazySeq = function lazySeq(realized, body) {
        return new LazySeq(realized, body);
    };
var cloneProtoProps = function cloneProtoProps(from, to) {
    return Object.assign.apply(void 0, [to].concat(Object.getOwnPropertyNames(from.__proto__).map(function ($1) {
        return function () {
            var xø1 = from[$1];
            return dictionary($1, isFn(xø1) ? xø1.bind(from) : xø1);
        }.call(this);
    })));
};
var identitySet = exports.identitySet = function identitySet() {
        var items = Array.prototype.slice.call(arguments, 0);
        return function () {
            var jsSetø1 = new Set(items);
            var fø1 = function ($1, $2) {
                return get.apply(void 0, [
                    jsSetø1,
                    $1,
                    $2
                ]);
            };
            cloneProtoProps(jsSetø1, fø1);
            fø1.toString = seqToString('#{', '}');
            fø1.__proto__ = jsSetø1;
            Object.defineProperty(fø1, 'length', { 'value': fø1.size });
            fø1[Symbol.iterator] = fø1.values;
            fø1['type'] = identitySet.type;
            return fø1;
        }.call(this);
    };
identitySet.type = (_wispTypes || 0)['set'];
var set = exports.set = identitySet;
var isLazySeq = exports.isLazySeq = isLazySeq;
var isIdentitySet = exports.isIdentitySet = isIdentitySet;
var isList = exports.isList = isList;
isEqual._seqEqual = function (x, y) {
    return (isVector(x) || isSeq(x)) && (isVector(y) || isSeq(y)) && function loop() {
        var recur = loop;
        var xø2 = seq(x);
        var yø2 = seq(y);
        do {
            recur = isVector(xø2) && isVector(yø2) ? isEqual(count(xø2), count(yø2)) && xø2.every(function ($1, $2) {
                return isEqual($1, yø2[$2]);
            }) : isEmpty(xø2) || isEmpty(yø2) ? isEmpty(xø2) && isEmpty(yø2) : !isEqual(first(xø2), first(yø2)) ? false : 'else' ? (loop[0] = rest(xø2), loop[1] = rest(yø2), loop) : void 0;
        } while (xø2 = loop[0], yø2 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var list = exports.list = function list() {
        return arguments.length === 0 ? Object.create(List.prototype) : Array.prototype.slice.call(arguments).reduceRight(function (tail, head) {
            return cons(head, tail);
        }, list());
    };
var cons = exports.cons = function cons(head, tail) {
        return new List(head, tail);
    };
var isSequential = exports.isSequential = function isSequential(x) {
        return isSeq(x) || isVector(x) || isDictionary(x) || isSet(x) || isString(x);
    };
var isNative = function isNative(sequence) {
    return isVector(sequence) || isString(sequence) || isDictionary(sequence);
};
var reverse = exports.reverse = function reverse(sequence) {
        return isVector(sequence) ? vec(sequence).reverse() : into(void 0, sequence);
    };
var range = exports.range = function range() {
        switch (arguments.length) {
        case 1:
            var end = arguments[0];
            return range(0, end, 1);
        case 2:
            var start = arguments[0];
            var end = arguments[1];
            return range(start, end, 1);
        case 3:
            var start = arguments[0];
            var end = arguments[1];
            var step = arguments[2];
            return step < 0 ? range(0 - start, 0 - end, 0 - step).map(function ($1) {
                return 0 - $1;
            }) : Array.from({ 'length': (end + step - start - 1) / step }, function (_, i) {
                return start + i * step;
            });
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var mapv = exports.mapv = function mapv(f) {
        var sequences = Array.prototype.slice.call(arguments, 1);
        return function () {
            var vectorsø1 = sequences.map(vec);
            var nø1 = min.apply(void 0, vectorsø1.map(count));
            return range(nø1).map(function (i) {
                return f.apply(void 0, vectorsø1.map(function ($1) {
                    return $1[i];
                }));
            });
        }.call(this);
    };
var map = exports.map = function map(f) {
        var sequences = Array.prototype.slice.call(arguments, 1);
        return function () {
            var resultø1 = mapv.apply(void 0, [f].concat(sequences));
            return isNative(first(sequences)) ? resultø1 : list.apply(void 0, resultø1);
        }.call(this);
    };
var mapIndexed = exports.mapIndexed = function mapIndexed(f) {
        var sequences = Array.prototype.slice.call(arguments, 1);
        return function () {
            var sequenceø1 = first(sequences);
            var nø1 = count(sequenceø1);
            var indicesø1 = range(nø1);
            return map.apply(void 0, [
                f,
                isNative(sequenceø1) ? indicesø1 : list.apply(void 0, indicesø1)
            ].concat(sequences));
        }.call(this);
    };
var filter = exports.filter = function filter(isF, sequence) {
        return isNil(sequence) ? list() : isSeq(sequence) ? filterList(isF, sequence) : isVector(sequence) ? sequence.filter(function ($1) {
            return isF($1);
        }) : 'else' ? filter(isF, seq(sequence)) : void 0;
    };
var filterList = function filterList(isF, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = list();
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? reverse(resultø1) : (loop[0] = isF(first(itemsø1)) ? cons(first(itemsø1), resultø1) : resultø1, loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var filterv = exports.filterv = function filterv(isF, sequence) {
        return vec(filter(isF, sequence));
    };
var reduce = exports.reduce = function reduce(f) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var hasInitialø1 = count(params) >= 2;
            var initialø1 = hasInitialø1 ? first(params) : void 0;
            var sequenceø1 = hasInitialø1 ? second(params) : first(params);
            return hasInitialø1 ? vec(sequenceø1).reduce(f, initialø1) : vec(sequenceø1).reduce(f);
        }.call(this);
    };
var count = exports.count = function count(sequence) {
        return sequence && isNumber(sequence.length) ? sequence.length : function () {
            var itø1 = seq(sequence);
            return isNil(itø1) ? 0 : isLazySeq(itø1) ? count(vec(itø1)) : 'else' ? itø1.length : void 0;
        }.call(this);
    };
var isEmpty = exports.isEmpty = function isEmpty(sequence) {
        return function () {
            var itø1 = seq(sequence);
            return 0 === (!isLazySeq(itø1) ? count(itø1) : (function () {
                first(itø1);
                return itø1.length;
            })());
        }.call(this);
    };
var first = exports.first = function first(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? sequence.head : isVector(sequence) || isString(sequence) ? (sequence || 0)[0] : isLazySeq(sequence) ? first(lazySeqValue(sequence)) : 'else' ? first(seq(sequence)) : void 0;
    };
var second = exports.second = function second(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? first(rest(sequence)) : isVector(sequence) || isString(sequence) ? (sequence || 0)[1] : isLazySeq(sequence) ? second(lazySeqValue(sequence)) : 'else' ? first(rest(seq(sequence))) : void 0;
    };
var third = exports.third = function third(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? first(rest(rest(sequence))) : isVector(sequence) || isString(sequence) ? (sequence || 0)[2] : isLazySeq(sequence) ? third(lazySeqValue(sequence)) : 'else' ? second(rest(seq(sequence))) : void 0;
    };
var rest = exports.rest = function rest(sequence) {
        return isNil(sequence) ? list() : isList(sequence) ? sequence.tail : isVector(sequence) || isString(sequence) ? sequence.slice(1) : isLazySeq(sequence) ? rest(lazySeqValue(sequence)) : 'else' ? rest(seq(sequence)) : void 0;
    };
var lastOfList = function lastOfList(list) {
    return function loop() {
        var recur = loop;
        var itemø1 = first(list);
        var itemsø1 = rest(list);
        do {
            recur = isEmpty(itemsø1) ? itemø1 : (loop[0] = first(itemsø1), loop[1] = rest(itemsø1), loop);
        } while (itemø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var last = exports.last = function last(sequence) {
        return isVector(sequence) || isString(sequence) ? (sequence || 0)[dec(count(sequence))] : isList(sequence) ? lastOfList(sequence) : isNil(sequence) ? void 0 : isLazySeq(sequence) ? last(lazySeqValue(sequence)) : 'else' ? last(seq(sequence)) : void 0;
    };
var butlast = exports.butlast = function butlast(sequence) {
        return function () {
            var itemsø1 = isNil(sequence) ? void 0 : isString(sequence) ? subs(sequence, 0, dec(count(sequence))) : isVector(sequence) ? sequence.slice(0, dec(count(sequence))) : isList(sequence) ? list.apply(void 0, butlast(vec(sequence))) : isLazySeq(sequence) ? butlast(lazySeqValue(sequence)) : 'else' ? butlast(seq(sequence)) : void 0;
            return !isEmpty(itemsø1) ? itemsø1 : void 0;
        }.call(this);
    };
var take = exports.take = function take(n, sequence) {
        return isNil(sequence) ? list() : isVector(sequence) ? takeFromVector(n, sequence) : isList(sequence) ? takeFromList(n, sequence) : isLazySeq(sequence) ? n > 0 ? take(n, lazySeqValue(sequence)) : void 0 : 'else' ? take(n, seq(sequence)) : void 0;
    };
var takeWhile = exports.takeWhile = function takeWhile(predicate, sequence) {
        return function loop() {
            var recur = loop;
            var itemsø1 = sequence;
            var resultø1 = [];
            do {
                recur = function () {
                    var headø1 = first(itemsø1);
                    var tailø1 = rest(itemsø1);
                    return !isEmpty(itemsø1) && predicate(headø1) ? (loop[0] = tailø1, loop[1] = conj(resultø1, headø1), loop) : isNative(sequence) ? resultø1 : list.apply(void 0, resultø1);
                }.call(this);
            } while (itemsø1 = loop[0], resultø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var takeFromVector = function takeFromVector(n, vector) {
    return vector.slice(0, n);
};
var takeFromList = function takeFromList(n, sequence) {
    return function loop() {
        var recur = loop;
        var takenø1 = list();
        var itemsø1 = sequence;
        var nø2 = int(n) || 0;
        do {
            recur = nø2 <= 0 || isEmpty(itemsø1) ? reverse(takenø1) : (loop[0] = cons(first(itemsø1), takenø1), loop[1] = rest(itemsø1), loop[2] = dec(nø2), loop);
        } while (takenø1 = loop[0], itemsø1 = loop[1], nø2 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var dropFromList = function dropFromList(n, sequence) {
    return function loop() {
        var recur = loop;
        var leftø1 = n;
        var itemsø1 = sequence;
        do {
            recur = leftø1 < 1 || isEmpty(itemsø1) ? itemsø1 : (loop[0] = dec(leftø1), loop[1] = rest(itemsø1), loop);
        } while (leftø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var drop = exports.drop = function drop(n, sequence) {
        return n <= 0 ? sequence : isString(sequence) ? sequence.substr(n) : isVector(sequence) ? sequence.slice(n) : isList(sequence) ? dropFromList(n, sequence) : isNil(sequence) ? list() : isLazySeq(sequence) ? drop(n, lazySeqValue(sequence)) : 'else' ? drop(n, seq(sequence)) : void 0;
    };
var dropWhile = exports.dropWhile = function dropWhile(predicate, sequence) {
        return function loop() {
            var recur = loop;
            var itemsø1 = seq(sequence);
            do {
                recur = isEmpty(itemsø1) || !predicate(first(itemsø1)) ? itemsø1 : (loop[0] = rest(itemsø1), loop);
            } while (itemsø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var conjList = function conjList(sequence, items) {
    return reduce(function (result, item) {
        return cons(item, result);
    }, sequence, items);
};
var ensureDictionary = function ensureDictionary(x) {
    return !isVector(x) ? x : dictionary(first(x), second(x));
};
var conj = exports.conj = function conj(sequence) {
        var items = Array.prototype.slice.call(arguments, 1);
        return isVector(sequence) ? sequence.concat(items) : isString(sequence) ? '' + sequence + str.apply(void 0, items) : isNil(sequence) ? list.apply(void 0, reverse(items)) : isSeq(sequence) ? conjList(sequence, items) : isDictionary(sequence) ? merge(sequence, merge.apply(void 0, mapv(ensureDictionary, items))) : isSet(sequence) ? identitySet.apply(void 0, into(vec(sequence), items)) : 'else' ? (function () {
            throw TypeError('' + 'Type can\'t be conjoined ' + sequence);
        })() : void 0;
    };
var disj = exports.disj = function disj(coll) {
        var ks = Array.prototype.slice.call(arguments, 1);
        return function () {
            var predicateø1 = complement(identitySet.apply(void 0, ks));
            return isEmpty(ks) ? coll : isSet(coll) ? identitySet.apply(void 0, filterv(predicateø1, coll)) : isDictionary(coll) ? into({}, filter(function ($1) {
                return predicateø1(first($1));
            }, coll)) : 'else' ? (function () {
                throw TypeError('' + 'Type can\'t be disjoined ' + coll);
            })() : void 0;
        }.call(this);
    };
var into = exports.into = function into(to, from) {
        return conj.apply(void 0, [to].concat(vec(from)));
    };
var zipmap = exports.zipmap = function zipmap(keys, vals) {
        return into({}, map(vector, keys, vals));
    };
var assoc = exports.assoc = function assoc(source) {
        var keyValues = Array.prototype.slice.call(arguments, 1);
        return conj(source, dictionary.apply(void 0, keyValues));
    };
var dissoc = exports.dissoc = function dissoc(coll) {
        var ks = Array.prototype.slice.call(arguments, 1);
        return isDictionary(coll) ? disj.apply(void 0, [coll].concat(ks)) : (function () {
            throw TypeError('' + 'Can only dissoc on dictionaries');
        })();
    };
var concat = exports.concat = function concat() {
        var sequences = Array.prototype.slice.call(arguments, 0);
        return reduce(function ($1, $2) {
            return conjList($1, reverse($2));
        }, function () {
            var tailø1 = last(sequences);
            return isLazySeq(tailø1) ? tailø1 : list.apply(void 0, vec(tailø1));
        }.call(this), rest(reverse(sequences)));
    };
var mapcat = exports.mapcat = function mapcat(f) {
        var colls = Array.prototype.slice.call(arguments, 1);
        return concat.apply(void 0, mapv.apply(void 0, [f].concat(colls)));
    };
var empty = exports.empty = function empty(sequence) {
        return isList(sequence) ? list() : isVector(sequence) ? [] : isString(sequence) ? '' : isDictionary(sequence) ? {} : isSet(sequence) ? set() : isLazySeq(sequence) ? lazySeq.call(void 0, false, function () {
            return void 0;
        }) : void 0;
    };
var seq = exports.seq = function seq(sequence) {
        return isNil(sequence) ? void 0 : isVector(sequence) || isSeq(sequence) ? sequence : isString(sequence) ? Array.prototype.slice.call(sequence) : isDictionary(sequence) ? keyValues(sequence) : isIterable(sequence) ? iteratorToLseq((sequence || 0)[Symbol.iterator]()) : 'default' ? (function () {
            throw TypeError('' + 'Can not seq ' + sequence);
        })() : void 0;
    };
var seq_ = exports.seq_ = function seq_(sequence) {
        return function () {
            var itø1 = seq(sequence);
            return !isEmpty(itø1) ? itø1 : void 0;
        }.call(this);
    };
var isSeq = exports.isSeq = function isSeq(sequence) {
        return isList(sequence) || isLazySeq(sequence);
    };
var iteratorToLseq = function iteratorToLseq(iterator) {
    return unfold(function ($1) {
        return function () {
            var xø1 = $1.next();
            return !xø1.done ? [
                xø1.value,
                $1
            ] : void 0;
        }.call(this);
    }, iterator);
};
var vec = exports.vec = function vec(sequence) {
        return isNil(sequence) ? [] : isVector(sequence) || isList(sequence) ? Array.from(sequence) : isLazySeq(sequence) ? function () {
            var xsø1 = Array.from(sequence);
            sequence.length = xsø1.length;
            return xsø1;
        }.call(this) : 'else' ? vec(seq(sequence)) : void 0;
    };
var vector = exports.vector = function vector() {
        var sequence = Array.prototype.slice.call(arguments, 0);
        return sequence;
    };
var sortComparator = isEqual([
        1,
        2,
        3
    ], [
        2,
        1,
        3
    ].sort(function (a, b) {
        return a < b ? 0 : 1;
    })) ? function ($1) {
        return function (a, b) {
            return $1(b, a) ? 1 : 0;
        };
    } : function ($1) {
        return function (a, b) {
            return $1(a, b) ? -1 : 0;
        };
    };
var sort = exports.sort = function sort(f, items) {
        return function () {
            var hasComparatorø1 = isFn(f);
            var itemsø2 = !hasComparatorø1 && isNil(items) ? f : items;
            var compareø1 = hasComparatorø1 ? sortComparator(f) : void 0;
            var resultø1 = vec(itemsø2).sort(compareø1);
            return isNil(itemsø2) ? list() : isVector(itemsø2) ? resultø1 : 'else' ? list.apply(void 0, resultø1) : void 0;
        }.call(this);
    };
var repeatedly = exports.repeatedly = function repeatedly(n, f) {
        return Array.from({ 'length': n }, f);
    };
var repeat = exports.repeat = function repeat(n, x) {
        return repeatedly(n, function () {
            return x;
        });
    };
var isEvery = exports.isEvery = function isEvery(predicate, sequence) {
        return vec(sequence).every(function ($1) {
            return predicate($1);
        });
    };
var some = exports.some = function some(pred, coll) {
        return function loop() {
            var recur = loop;
            var itemsø1 = seq(coll);
            do {
                recur = !isEmpty(itemsø1) ? pred(first(itemsø1)) || (loop[0] = rest(itemsø1), loop) : void 0;
            } while (itemsø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var partition = exports.partition = function partition() {
        switch (arguments.length) {
        case 2:
            var n = arguments[0];
            var coll = arguments[1];
            return partition(n, n, coll);
        case 3:
            var n = arguments[0];
            var step = arguments[1];
            var coll = arguments[2];
            return partition(n, step, [], coll);
        case 4:
            var n = arguments[0];
            var step = arguments[1];
            var pad = arguments[2];
            var coll = arguments[3];
            return function loop() {
                var recur = loop;
                var resultø1 = [];
                var itemsø1 = seq(coll);
                do {
                    recur = function () {
                        var chunkø1 = take(n, itemsø1);
                        var sizeø1 = count(chunkø1);
                        return sizeø1 === n ? (loop[0] = conj(resultø1, chunkø1), loop[1] = drop(step, itemsø1), loop) : 0 === sizeø1 ? resultø1 : n > sizeø1 + count(pad) ? resultø1 : 'else' ? conj(resultø1, take(n, vec(concat(chunkø1, pad)))) : void 0;
                    }.call(this);
                } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var interleave = exports.interleave = function interleave() {
        var sequences = Array.prototype.slice.call(arguments, 0);
        return isEmpty(sequences) ? [] : function loop() {
            var recur = loop;
            var resultø1 = [];
            var sequencesø2 = sequences;
            do {
                recur = some(isEmpty, sequencesø2) ? vec(resultø1) : (loop[0] = concat(resultø1, map(first, sequencesø2)), loop[1] = map(rest, sequencesø2), loop);
            } while (resultø1 = loop[0], sequencesø2 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var nth = exports.nth = function nth(sequence, index, notFound) {
        return function () {
            var sequenceø2 = seq_(sequence);
            return isNil(sequenceø2) ? notFound : isSeq(sequenceø2) ? function () {
                var ifLetBinding1ø1 = seq_(drop(index, sequenceø2));
                return ifLetBinding1ø1 ? function () {
                    var itø1 = ifLetBinding1ø1;
                    return first(itø1);
                }.call(this) : notFound;
            }.call(this) : isVector(sequenceø2) || isString(sequenceø2) ? index < count(sequenceø2) ? sequenceø2[index] : notFound : 'else' ? (function () {
                throw TypeError('Unsupported type');
            })() : void 0;
        }.call(this);
    };
var isContains = exports.isContains = function isContains(coll, v) {
        return isSet(coll) ? coll.has(v) : isDictionary(coll) || isVector(coll) || isString(coll) ? coll.hasOwnProperty(v) : 'else' ? false : void 0;
    };
var union = exports.union = function union() {
        var sets = Array.prototype.slice.call(arguments, 0);
        return into(set(), concat.apply(void 0, sets));
    };
var difference = exports.difference = function difference(s1) {
        var sets = Array.prototype.slice.call(arguments, 1);
        return into(set(), filter(complement(union.apply(void 0, sets)), s1));
    };
var intersection = exports.intersection = function intersection() {
        var sets = Array.prototype.slice.call(arguments, 0);
        return function () {
            var setsø2 = mapv(function ($1) {
                    return into(set(), $1);
                }, sets);
            var isInEachø1 = function (x) {
                return isEvery(function ($1) {
                    return $1.has(x);
                }, setsø2);
            };
            var minSizeø1 = min.apply(void 0, mapv(count, setsø2));
            var smallestø1 = setsø2.find(function ($1) {
                    return isEqual(minSizeø1, count($1));
                });
            return into(set(), filter(isInEachø1, smallestø1));
        }.call(this);
    };
var isSubset = exports.isSubset = function isSubset(set1, set2) {
        return isSet(set2) ? isEvery(function ($1) {
            return set2.has($1);
        }, set1) : isSubset(set1, into(set(), set2));
    };
var isSuperset = exports.isSuperset = function isSuperset(set1, set2) {
        return isSubset(set2, set1);
    };
var unfold = exports.unfold = function unfold(f, x) {
        return lazySeq.call(void 0, false, function () {
            return function () {
                var ifLetBinding2ø1 = f(x);
                return ifLetBinding2ø1 ? function () {
                    var nextø1 = ifLetBinding2ø1;
                    return cons(first(nextø1), unfold(f, second(nextø1)));
                }.call(this) : void 0;
            }.call(this);
        });
    };
var iterate = exports.iterate = function iterate(f, x) {
        return lazySeq.call(void 0, false, function () {
            return cons(x, iterate(f, f(x)));
        });
    };
var cycle = exports.cycle = function cycle(coll) {
        return lazySeq.call(void 0, false, function () {
            return !isEmpty(coll) ? concat(coll, cycle(coll)) : void 0;
        });
    };
var infiniteRange = exports.infiniteRange = function infiniteRange() {
        switch (arguments.length) {
        case 0:
            return infiniteRange(0);
        case 1:
            var n = arguments[0];
            return iterate(inc, n);
        case 2:
            var n = arguments[0];
            var step = arguments[1];
            return iterate(function ($1) {
                return $1 + step;
            }, n);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var lazyMap = exports.lazyMap = function lazyMap(f) {
        var sequences = Array.prototype.slice.call(arguments, 1);
        return unfold(function ($1) {
            return !some(isEmpty, $1) ? [
                f.apply(void 0, mapv(first, $1)),
                mapv(rest, $1)
            ] : void 0;
        }, sequences);
    };
var lazyFilter = exports.lazyFilter = function lazyFilter(f, sequence) {
        return unfold(function ($1) {
            return function loop() {
                var recur = loop;
                var xsø1 = $1;
                do {
                    recur = isEmpty(xsø1) ? void 0 : f(first(xsø1)) ? [
                        first(xsø1),
                        rest(xsø1)
                    ] : 'else' ? (loop[0] = rest(xsø1), loop) : void 0;
                } while (xsø1 = loop[0], recur === loop);
                return recur;
            }.call(this);
        }, seq(sequence));
    };
var lazyConcat = exports.lazyConcat = function lazyConcat() {
        var sequences = Array.prototype.slice.call(arguments, 0);
        return !isEmpty(sequences) ? function iter(xs) {
            return lazySeq.call(void 0, false, function () {
                return isEmpty(xs) ? lazyConcat.apply(void 0, rest(sequences)) : cons(first(xs), iter(rest(xs)));
            });
        }(seq(first(sequences))) : void 0;
    };
var lazyPartition = exports.lazyPartition = function lazyPartition() {
        switch (arguments.length) {
        case 2:
            var n = arguments[0];
            var coll = arguments[1];
            return lazyPartition(n, n, coll);
        case 3:
            var n = arguments[0];
            var step = arguments[1];
            var coll = arguments[2];
            return lazyPartition(n, step, [], coll);
        case 4:
            var n = arguments[0];
            var step = arguments[1];
            var pad = arguments[2];
            var coll = arguments[3];
            return unfold(function ($1) {
                return function () {
                    var chunkø1 = take(n, concat(take(n, $1), pad));
                    return !isEmpty($1) && n === count(chunkø1) ? [
                        chunkø1,
                        drop(step, $1)
                    ] : void 0;
                }.call(this);
            }, coll);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var run = exports.run = function run(proc, coll) {
        return reduce(function (_, x) {
            proc(x);
            return void 0;
        }, void 0, coll);
    };
var dorun = exports.dorun = function dorun() {
        switch (arguments.length) {
        case 1:
            var coll = arguments[0];
            return dorun(Infinity, coll);
        case 2:
            var n = arguments[0];
            var coll = arguments[1];
            return run(identity, take(n, coll));
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var doall = exports.doall = function doall() {
        switch (arguments.length) {
        case 1:
            var coll = arguments[0];
            return doall(Infinity, coll);
        case 2:
            var n = arguments[0];
            var coll = arguments[1];
            dorun(n, coll);
            return coll;
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImlzTmlsIiwiaXNWZWN0b3IiLCJpc0ZuIiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsImlzRGljdGlvbmFyeSIsImlzU2V0Iiwia2V5VmFsdWVzIiwic3RyIiwiaW50IiwiZGVjIiwiaW5jIiwibWluIiwibWVyZ2UiLCJkaWN0aW9uYXJ5IiwiZ2V0IiwiaXNJdGVyYWJsZSIsImlzRXF1YWwiLCJjb21wbGVtZW50IiwiaWRlbnRpdHkiLCJpc0xpc3QiLCJpc0xhenlTZXEiLCJpc0lkZW50aXR5U2V0IiwiX3dpc3BUeXBlcyIsImxpc3RJdGVyYXRvciIsInNlbGbDuDEiLCJ0aGlzIiwiaXNFbXB0eSIsInjDuDEiLCJmaXJzdCIsInJlc3QiLCJzZXFUb1N0cmluZyIsImxwYXJlbiIsInJwYXJlbiIsImxpc3TDuDEiLCJyZXN1bHTDuDEiLCJzdWJzdHIiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsIkxpc3QiLCJoZWFkIiwidGFpbCIsImxpc3QiLCJsZW5ndGgiLCJjb3VudCIsInByb3RvdHlwZS5sZW5ndGgiLCJ0eXBlIiwicHJvdG90eXBlLnR5cGUiLCJwcm90b3R5cGUudGFpbCIsIk9iamVjdCIsImNyZWF0ZSIsInByb3RvdHlwZSIsInByb3RvdHlwZS50b1N0cmluZyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibGF6eVNlcVZhbHVlIiwibGF6eVNlcSIsInJlYWxpemVkIiwieCIsIkxhenlTZXEiLCJleHBvcnRzIiwiYm9keSIsImNsb25lUHJvdG9Qcm9wcyIsImZyb20iLCJ0byIsImFzc2lnbiIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX3Byb3RvX18iLCJtYXAiLCIkMSIsImJpbmQiLCJpZGVudGl0eVNldCIsIml0ZW1zIiwianNTZXTDuDEiLCJmw7gxIiwiJDIiLCJ0b1N0cmluZyIsImRlZmluZVByb3BlcnR5Iiwic2l6ZSIsInZhbHVlcyIsInNldCIsIl9zZXFFcXVhbCIsInkiLCJpc1NlcSIsInjDuDIiLCJzZXEiLCJ5w7gyIiwiZXZlcnkiLCJhcmd1bWVudHMiLCJBcnJheSIsInByb3RvdHlwZS5zbGljZSIsImNhbGwiLCJyZWR1Y2VSaWdodCIsImNvbnMiLCJpc1NlcXVlbnRpYWwiLCJpc05hdGl2ZSIsInNlcXVlbmNlIiwicmV2ZXJzZSIsInZlYyIsImludG8iLCJyYW5nZSIsImVuZCIsInN0YXJ0Iiwic3RlcCIsIl8iLCJpIiwibWFwdiIsImYiLCJzZXF1ZW5jZXMiLCJ2ZWN0b3Jzw7gxIiwibsO4MSIsIm1hcEluZGV4ZWQiLCJzZXF1ZW5jZcO4MSIsImluZGljZXPDuDEiLCJmaWx0ZXIiLCJpc0YiLCJmaWx0ZXJMaXN0IiwiaXRlbXPDuDEiLCJmaWx0ZXJ2IiwicmVkdWNlIiwicGFyYW1zIiwiaGFzSW5pdGlhbMO4MSIsImluaXRpYWzDuDEiLCJzZWNvbmQiLCJpdMO4MSIsInRoaXJkIiwic2xpY2UiLCJsYXN0T2ZMaXN0IiwiaXRlbcO4MSIsImxhc3QiLCJidXRsYXN0Iiwic3VicyIsInRha2UiLCJuIiwidGFrZUZyb21WZWN0b3IiLCJ0YWtlRnJvbUxpc3QiLCJ0YWtlV2hpbGUiLCJwcmVkaWNhdGUiLCJoZWFkw7gxIiwidGFpbMO4MSIsImNvbmoiLCJ2ZWN0b3IiLCJ0YWtlbsO4MSIsIm7DuDIiLCJkcm9wRnJvbUxpc3QiLCJsZWZ0w7gxIiwiZHJvcCIsImRyb3BXaGlsZSIsImNvbmpMaXN0IiwicmVzdWx0IiwiaXRlbSIsImVuc3VyZURpY3Rpb25hcnkiLCJjb25jYXQiLCJUeXBlRXJyb3IiLCJkaXNqIiwiY29sbCIsImtzIiwicHJlZGljYXRlw7gxIiwiemlwbWFwIiwia2V5cyIsInZhbHMiLCJhc3NvYyIsInNvdXJjZSIsImRpc3NvYyIsIm1hcGNhdCIsImNvbGxzIiwiZW1wdHkiLCJpdGVyYXRvclRvTHNlcSIsInNlcV8iLCJ1bmZvbGQiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwieHPDuDEiLCJzb3J0Q29tcGFyYXRvciIsInNvcnQiLCJhIiwiYiIsImhhc0NvbXBhcmF0b3LDuDEiLCJpdGVtc8O4MiIsImNvbXBhcmXDuDEiLCJyZXBlYXRlZGx5IiwicmVwZWF0IiwiaXNFdmVyeSIsInNvbWUiLCJwcmVkIiwicGFydGl0aW9uIiwicGFkIiwiY2h1bmvDuDEiLCJzaXplw7gxIiwiaW50ZXJsZWF2ZSIsInNlcXVlbmNlc8O4MiIsIm50aCIsImluZGV4Iiwibm90Rm91bmQiLCJzZXF1ZW5jZcO4MiIsImlzQ29udGFpbnMiLCJ2IiwiaGFzIiwiaGFzT3duUHJvcGVydHkiLCJ1bmlvbiIsInNldHMiLCJkaWZmZXJlbmNlIiwiczEiLCJpbnRlcnNlY3Rpb24iLCJzZXRzw7gyIiwiaXNJbkVhY2jDuDEiLCJtaW5TaXplw7gxIiwic21hbGxlc3TDuDEiLCJmaW5kIiwiaXNTdWJzZXQiLCJzZXQxIiwic2V0MiIsImlzU3VwZXJzZXQiLCJuZXh0w7gxIiwiaXRlcmF0ZSIsImN5Y2xlIiwiaW5maW5pdGVSYW5nZSIsImxhenlNYXAiLCJsYXp5RmlsdGVyIiwibGF6eUNvbmNhdCIsIml0ZXIiLCJ4cyIsImxhenlQYXJ0aXRpb24iLCJydW4iLCJwcm9jIiwiZG9ydW4iLCJJbmZpbml0eSIsImRvYWxsIl0sIm1hcHBpbmdzIjoiO0lBQUEsSUFBQ0EsSSxHQUFEO0FBQUEsWUFBQUMsRSxFQUFJLGVBQUo7QUFBQSxZQUFBQyxHLEVBQUEsSyxDQUFBO0FBQUEsVTs7UUFDa0NDLEtBQUEsRyxhQUFBQSxLO1FBQUtDLFFBQUEsRyxhQUFBQSxRO1FBQVFDLElBQUEsRyxhQUFBQSxJO1FBQUlDLFFBQUEsRyxhQUFBQSxRO1FBQVFDLFFBQUEsRyxhQUFBQSxRO1FBQVFDLFlBQUEsRyxhQUFBQSxZO1FBQVlDLEtBQUEsRyxhQUFBQSxLO1FBQzdDQyxTQUFBLEcsYUFBQUEsUztRQUFXQyxHQUFBLEcsYUFBQUEsRztRQUFJQyxHQUFBLEcsYUFBQUEsRztRQUFJQyxHQUFBLEcsYUFBQUEsRztRQUFJQyxHQUFBLEcsYUFBQUEsRztRQUFJQyxHQUFBLEcsYUFBQUEsRztRQUFJQyxLQUFBLEcs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LElBQU15RSxLQUFBLEdBQUF4SyxPQUFBLENBQUF3SyxLQUFBLEdBQU4sU0FBTUEsS0FBTixHOzs7Z0JBT0l6RSxJQUFBLEc7WUFBTSxPQUFDeUUsS0FBRCxDQUFPRCxRQUFQLEVBQWdCeEUsSUFBaEIsRTs7Z0JBQ050QixDQUFBLEc7Z0JBQUVzQixJQUFBLEc7WUFBT3VFLEtBQUQsQ0FBTzdGLENBQVAsRUFBU3NCLElBQVQsRTtZQUFlLE9BQUFBLElBQUEsQzs7OztLQVIzQiIsInNvdXJjZXNDb250ZW50IjpbIihucyB3aXNwLnNlcXVlbmNlXG4gICg6cmVxdWlyZSBbd2lzcC5ydW50aW1lIDpyZWZlciBbbmlsPyB2ZWN0b3I/IGZuPyBudW1iZXI/IHN0cmluZz8gZGljdGlvbmFyeT8gc2V0P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS12YWx1ZXMgc3RyIGludCBkZWMgaW5jIG1pbiBtZXJnZSBkaWN0aW9uYXJ5IGdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhYmxlPyA9IGNvbXBsZW1lbnQgaWRlbnRpdHkgbGlzdD8gbGF6eS1zZXE/IGlkZW50aXR5LXNldD9dXSkpXG5cbihkZWYgXjpwcml2YXRlIC13aXNwLXR5cGVzIChhZ2V0ID0gJy13aXNwLXR5cGVzKSlcblxuOzsgSW1wbGVtZW50YXRpb24gb2YgbGlzdFxuXG4oZGVmbi0gbGlzdC1pdGVyYXRvciBbXVxuICAobGV0IFtzZWxmIHRoaXNdXG4gICAgezpuZXh0ICMoaWYgKGVtcHR5PyBzZWxmKVxuICAgICAgICAgICAgICB7OmRvbmUgdHJ1ZX1cbiAgICAgICAgICAgICAgKGxldCBbeCAoZmlyc3Qgc2VsZildXG4gICAgICAgICAgICAgICAgKHNldCEgc2VsZiAocmVzdCBzZWxmKSlcbiAgICAgICAgICAgICAgICB7OnZhbHVlIHh9KSl9KSlcblxuKGRlZm4tIHNlcS0+c3RyaW5nIFtscGFyZW4gcnBhcmVuXVxuICAoZm4gW11cbiAgICAobG9vcCBbbGlzdCB0aGlzLCByZXN1bHQgXCJcIl1cbiAgICAgIChpZiAoZW1wdHk/IGxpc3QpXG4gICAgICAgIChzdHIgbHBhcmVuICguc3Vic3RyIHJlc3VsdCAxKSBycGFyZW4pXG4gICAgICAgIChyZWN1ciAocmVzdCBsaXN0KVxuICAgICAgICAgICAgICAgKHN0ciByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICAgICAgICAgICAgKGxldCBbeCAoZmlyc3QgbGlzdCldXG4gICAgICAgICAgICAgICAgICAgICAgKGNvbmQgKHZlY3Rvcj8geCkgKHN0ciBcIltcIiAoLmpvaW4geCBcIiBcIikgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5pbD8gICAgeCkgXCJuaWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHJpbmc/IHgpICguc3RyaW5naWZ5IEpTT04geClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVtYmVyPyB4KSAoLnN0cmluZ2lmeSBKU09OIHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVsc2UgICAgICAgeCkpKSkpKSkpXG5cbihkZWZuLSBMaXN0XG4gIFwiTGlzdCB0eXBlXCJcbiAgW2hlYWQgdGFpbF1cbiAgKHNldCEgdGhpcy5oZWFkIGhlYWQpXG4gIChzZXQhIHRoaXMudGFpbCAob3IgdGFpbCAobGlzdCkpKVxuICAoc2V0ISB0aGlzLmxlbmd0aFxuICAgIChpZiAob3IgKG5pbD8gdGhpcy50YWlsKSAoZGljdGlvbmFyeT8gdGhpcy50YWlsKSAobnVtYmVyPyAoLi1sZW5ndGggdGhpcy50YWlsKSkpXG4gICAgICAoaW5jIChjb3VudCB0aGlzLnRhaWwpKSkpXG4gIHRoaXMpXG5cbihzZXQhIExpc3QucHJvdG90eXBlLmxlbmd0aCAwKVxuKHNldCEgTGlzdC50eXBlICg6bGlzdCAtd2lzcC10eXBlcykpXG4oc2V0ISBMaXN0LnByb3RvdHlwZS50eXBlIExpc3QudHlwZSlcbihzZXQhIExpc3QucHJvdG90eXBlLnRhaWwgKE9iamVjdC5jcmVhdGUgTGlzdC5wcm90b3R5cGUpKVxuKHNldCEgTGlzdC5wcm90b3R5cGUudG8tc3RyaW5nIChzZXEtPnN0cmluZyBcIihcIiBcIilcIikpXG4oYXNldCBMaXN0LnByb3RvdHlwZSBTeW1ib2wuaXRlcmF0b3IgbGlzdC1pdGVyYXRvcilcblxuKGRlZm4tIGxhenktc2VxLXZhbHVlIFtsYXp5LXNlcV1cbiAgKGlmICguLXJlYWxpemVkIGxhenktc2VxKVxuICAgICguLXggbGF6eS1zZXEpXG4gICAgKGxldCBbeCAoLnggbGF6eS1zZXEpXVxuICAgICAgKHNldCEgKC4tcmVhbGl6ZWQgbGF6eS1zZXEpIHRydWUpXG4gICAgICAoaWYgKGVtcHR5PyB4KVxuICAgICAgICAoc2V0ISAoLi1sZW5ndGggbGF6eS1zZXEpIDApKVxuICAgICAgKHNldCEgKC4teCBsYXp5LXNlcSkgeCkpKSlcblxuKGRlZm4tIExhenlTZXEgW3JlYWxpemVkIHhdXG4gIChzZXQhICguLXJlYWxpemVkIHRoaXMpIChvciByZWFsaXplZCBmYWxzZSkpXG4gIChzZXQhICguLXggdGhpcykgeClcbiAgdGhpcylcbihzZXQhIExhenlTZXEudHlwZSAoOmxhenktc2VxIC13aXNwLXR5cGVzKSlcbihzZXQhIExhenlTZXEucHJvdG90eXBlLnR5cGUgTGF6eVNlcS50eXBlKVxuKGFzZXQgTGF6eVNlcS5wcm90b3R5cGUgU3ltYm9sLml0ZXJhdG9yIGxpc3QtaXRlcmF0b3IpXG5cbihkZWZuIGxhenktc2VxXG4gIFtyZWFsaXplZCBib2R5XVxuICAoTGF6eVNlcS4gcmVhbGl6ZWQgYm9keSkpXG5cbihkZWZuLSBjbG9uZS1wcm90by1wcm9wcyEgW2Zyb20gdG9dXG4gIChhcHBseSBPYmplY3QuYXNzaWduIHRvXG4gICAgICAgICAoLm1hcCAoT2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMgZnJvbS5fX3Byb3RvX18pXG4gICAgICAgICAgICAgICAjKGxldCBbeCAoYWdldCBmcm9tICUpXVxuICAgICAgICAgICAgICAgICAgKGRpY3Rpb25hcnkgJSAoaWYgKGZuPyB4KSAoLmJpbmQgeCBmcm9tKSB4KSkpKSkpXG5cbihkZWZuIGlkZW50aXR5LXNldCBbJiBpdGVtc11cbiAgKGxldCBbanMtc2V0IChTZXQuIGl0ZW1zKVxuICAgICAgICBmICAgICAgIyhnZXQganMtc2V0ICUxICUyKV1cbiAgICAoY2xvbmUtcHJvdG8tcHJvcHMhIGpzLXNldCBmKVxuICAgIChzZXQhIGYudG8tc3RyaW5nIChzZXEtPnN0cmluZyBcIiN7XCIgXCJ9XCIpKVxuICAgIChzZXQhIGYuX19wcm90b19fIGpzLXNldClcbiAgICAoT2JqZWN0LmRlZmluZS1wcm9wZXJ0eSBmIDpsZW5ndGggezp2YWx1ZSBmLnNpemV9KVxuICAgIChhc2V0IGYgU3ltYm9sLml0ZXJhdG9yIGYudmFsdWVzKVxuICAgIChhc2V0IGYgOnR5cGUgaWRlbnRpdHktc2V0LnR5cGUpXG4gICAgZikpXG4oc2V0ISBpZGVudGl0eS1zZXQudHlwZSAoOnNldCAtd2lzcC10eXBlcykpXG4oZGVmIHNldCBpZGVudGl0eS1zZXQpXG5cbihkZWYgbGF6eS1zZXE/IGxhenktc2VxPylcbihkZWYgaWRlbnRpdHktc2V0PyBpZGVudGl0eS1zZXQ/KVxuKGRlZiBsaXN0PyBsaXN0PylcblxuKHNldCEgPS4qc2VxPVxuICAoZm4gW3ggeV1cbiAgICAoYW5kIChvciAodmVjdG9yPyB4KSAoc2VxPyB4KSlcbiAgICAgICAgIChvciAodmVjdG9yPyB5KSAoc2VxPyB5KSlcbiAgICAgICAgIChsb29wIFt4IChzZXEgeCksIHkgKHNlcSB5KV1cbiAgICAgICAgICAgKGNvbmQgKGFuZCAodmVjdG9yPyB4KSAodmVjdG9yPyB5KSkgKGFuZCAoPSAoY291bnQgeCkgKGNvdW50IHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICguZXZlcnkgeCAjKD0gJTEgKGFnZXQgeSAlMikpKSlcbiAgICAgICAgICAgICAgICAgKG9yIChlbXB0eT8geCkgKGVtcHR5PyB5KSkgICAgKGFuZCAoZW1wdHk/IHgpIChlbXB0eT8geSkpXG4gICAgICAgICAgICAgICAgIChub3Q9IChmaXJzdCB4KSAoZmlyc3QgeSkpICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgIDplbHNlICAgICAgICAgICAgICAgICAgICAgICAgIChyZWN1ciAocmVzdCB4KSAocmVzdCB5KSkpKSkpKVxuXG4oZGVmbiBsaXN0XG4gIFwiQ3JlYXRlcyBsaXN0IG9mIHRoZSBnaXZlbiBpdGVtc1wiXG4gIFtdXG4gIChpZiAoaWRlbnRpY2FsPyAoLi1sZW5ndGggYXJndW1lbnRzKSAwKVxuICAgIChPYmplY3QuY3JlYXRlIExpc3QucHJvdG90eXBlKVxuICAgICgucmVkdWNlLXJpZ2h0ICguY2FsbCBBcnJheS5wcm90b3R5cGUuc2xpY2UgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgIChmbiBbdGFpbCBoZWFkXSAoY29ucyBoZWFkIHRhaWwpKVxuICAgICAgICAgICAgICAgICAgIChsaXN0KSkpKVxuXG4oZGVmbiBjb25zXG4gIFwiQ3JlYXRlcyBsaXN0IHdpdGggYGhlYWRgIGFzIGZpcnN0IGl0ZW0gYW5kIGB0YWlsYCBhcyByZXN0XCJcbiAgW2hlYWQgdGFpbF1cbiAgKG5ldyBMaXN0IGhlYWQgdGFpbCkpXG5cbihkZWZuIF5ib29sZWFuIHNlcXVlbnRpYWw/XG4gIFwiUmV0dXJucyB0cnVlIGlmIGNvbGwgc2F0aXNmaWVzIElTZXF1ZW50aWFsXCJcbiAgW3hdIChvciAoc2VxPyB4KVxuICAgICAgICAgICh2ZWN0b3I/IHgpXG4gICAgICAgICAgKGRpY3Rpb25hcnk/IHgpXG4gICAgICAgICAgKHNldD8geClcbiAgICAgICAgICAoc3RyaW5nPyB4KSkpXG5cbihkZWZuLSBeYm9vbGVhbiBuYXRpdmU/IFtzZXF1ZW5jZV1cbiAgKG9yICh2ZWN0b3I/IHNlcXVlbmNlKSAoc3RyaW5nPyBzZXF1ZW5jZSkgKGRpY3Rpb25hcnk/IHNlcXVlbmNlKSkpXG5cblxuKGRlZm4gcmV2ZXJzZVxuICBcIlJldmVyc2Ugb3JkZXIgb2YgaXRlbXMgaW4gdGhlIHNlcXVlbmNlXCJcbiAgW3NlcXVlbmNlXVxuICAoaWYgKHZlY3Rvcj8gc2VxdWVuY2UpXG4gICAgKC5yZXZlcnNlICh2ZWMgc2VxdWVuY2UpKVxuICAgIChpbnRvIG5pbCBzZXF1ZW5jZSkpKVxuXG4oZGVmbiByYW5nZVxuICBcIlJldHVybnMgYSB2ZWN0b3Igb2YgbnVtcyBmcm9tIHN0YXJ0IChpbmNsdXNpdmUpIHRvIGVuZFxuICAoZXhjbHVzaXZlKSwgYnkgc3RlcCwgd2hlcmUgc3RhcnQgZGVmYXVsdHMgdG8gMCBhbmQgc3RlcCB0byAxLlwiXG4gIChbZW5kXSAgICAgICAgICAgIChyYW5nZSAwIGVuZCAxKSlcbiAgKFtzdGFydCBlbmRdICAgICAgKHJhbmdlIHN0YXJ0IGVuZCAxKSlcbiAgKFtzdGFydCBlbmQgc3RlcF0gKGlmICg8IHN0ZXAgMClcbiAgICAgICAgICAgICAgICAgICAgICAoLm1hcCAocmFuZ2UgKC0gc3RhcnQpICgtIGVuZCkgKC0gc3RlcCkpICMoLSAlKSlcbiAgICAgICAgICAgICAgICAgICAgICAoQXJyYXkuZnJvbSB7Omxlbmd0aCAoLT4gKCsgZW5kIHN0ZXApICgtIHN0YXJ0IDEpICgvIHN0ZXApKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZm4gW18gaV0gKCsgc3RhcnQgKCogaSBzdGVwKSkpKSkpKVxuXG4oZGVmbiBtYXB2XG4gIFwiUmV0dXJucyBhIHZlY3RvciBjb25zaXN0aW5nIG9mIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZVxuICBmaXJzdCBpdGVtcywgZm9sbG93ZWQgYnkgYXBwbHlpbmcgZiB0byB0aGUgc2Vjb25kIGl0ZW1zLCB1bnRpbCBvbmUgb2ZcbiAgc2VxdWVuY2VzIGlzIGV4aGF1c3RlZC5cIlxuICBbZiAmIHNlcXVlbmNlc11cbiAgKGxldCBbdmVjdG9ycyAoLm1hcCBzZXF1ZW5jZXMgdmVjKSwgIG4gKGFwcGx5IG1pbiAoLm1hcCB2ZWN0b3JzIGNvdW50KSldXG4gICAgKC5tYXAgKHJhbmdlIG4pIChmbiBbaV0gKGFwcGx5IGYgKC5tYXAgdmVjdG9ycyAjKGFnZXQgJSBpKSkpKSkpKVxuXG4oZGVmbiBtYXBcbiAgXCJSZXR1cm5zIGEgc2VxdWVuY2UgY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBmYCB0byB0aGVcbiAgZmlyc3QgaXRlbXMsIGZvbGxvd2VkIGJ5IGFwcGx5aW5nIGYgdG8gdGhlIHNlY29uZCBpdGVtcywgdW50aWwgb25lIG9mXG4gIHNlcXVlbmNlcyBpcyBleGhhdXN0ZWQuXCJcbiAgW2YgJiBzZXF1ZW5jZXNdXG4gIChsZXQgW3Jlc3VsdCAoYXBwbHkgbWFwdiBmIHNlcXVlbmNlcyldXG4gICAgKGlmIChuYXRpdmU/IChmaXJzdCBzZXF1ZW5jZXMpKSByZXN1bHQgKGFwcGx5IGxpc3QgcmVzdWx0KSkpKVxuXG4oZGVmbiBtYXAtaW5kZXhlZFxuICBcIlJldHVybnMgYSBzZXF1ZW5jZSBjb25zaXN0aW5nIG9mIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIDAgYW5kXG4gIHRoZSBmaXJzdCBpdGVtcywgZm9sbG93ZWQgYnkgYXBwbHlpbmcgZiB0byAxIGFuZCB0aGUgc2Vjb25kIGl0ZW1zLFxuICB1bnRpbCBvbmUgb2Ygc2VxdWVuY2VzIGlzIGV4aGF1c3RlZC5cIlxuICBbZiAmIHNlcXVlbmNlc11cbiAgKGxldCBbc2VxdWVuY2UgKGZpcnN0IHNlcXVlbmNlcyksICBuIChjb3VudCBzZXF1ZW5jZSksICBpbmRpY2VzIChyYW5nZSBuKV1cbiAgICAoYXBwbHkgbWFwIGYgKGlmIChuYXRpdmU/IHNlcXVlbmNlKSBpbmRpY2VzIChhcHBseSBsaXN0IGluZGljZXMpKSBzZXF1ZW5jZXMpKSlcblxuKGRlZm4gZmlsdGVyXG4gIFwiUmV0dXJucyBhIHNlcXVlbmNlIG9mIHRoZSBpdGVtcyBpbiBjb2xsIGZvciB3aGljaCAoZj8gaXRlbSkgcmV0dXJucyB0cnVlLlxuICBmPyBtdXN0IGJlIGZyZWUgb2Ygc2lkZS1lZmZlY3RzLlwiXG4gIFtmPyBzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpICAgICcoKVxuICAgICAgICAoc2VxPyBzZXF1ZW5jZSkgICAgKGZpbHRlci1saXN0IGY/IHNlcXVlbmNlKVxuICAgICAgICAodmVjdG9yPyBzZXF1ZW5jZSkgKC5maWx0ZXIgc2VxdWVuY2UgIyhmPyAlKSlcbiAgICAgICAgOmVsc2UgICAgICAgICAgICAgIChmaWx0ZXIgZj8gKHNlcSBzZXF1ZW5jZSkpKSlcblxuKGRlZm4tIGZpbHRlci1saXN0XG4gIFwiTGlrZSBmaWx0ZXIgYnV0IGZvciBsaXN0c1wiXG4gIFtmPyBzZXF1ZW5jZV1cbiAgKGxvb3AgW3Jlc3VsdCAnKClcbiAgICAgICAgIGl0ZW1zIHNlcXVlbmNlXVxuICAgIChpZiAoZW1wdHk/IGl0ZW1zKVxuICAgICAgKHJldmVyc2UgcmVzdWx0KVxuICAgICAgKHJlY3VyIChpZiAoZj8gKGZpcnN0IGl0ZW1zKSlcbiAgICAgICAgICAgICAgIChjb25zIChmaXJzdCBpdGVtcykgcmVzdWx0KVxuICAgICAgICAgICAgICAgcmVzdWx0KVxuICAgICAgICAgICAgIChyZXN0IGl0ZW1zKSkpKSlcblxuKGRlZm4gZmlsdGVydiBbZj8gc2VxdWVuY2VdXG4gICh2ZWMgKGZpbHRlciBmPyBzZXF1ZW5jZSkpKVxuXG4oZGVmbiByZWR1Y2VcbiAgW2YgJiBwYXJhbXNdXG4gIChsZXQgW2hhcy1pbml0aWFsICg+PSAoY291bnQgcGFyYW1zKSAyKVxuICAgICAgICBpbml0aWFsICAgICAoaWYgaGFzLWluaXRpYWwgKGZpcnN0IHBhcmFtcykpXG4gICAgICAgIHNlcXVlbmNlICAgIChpZiBoYXMtaW5pdGlhbCAoc2Vjb25kIHBhcmFtcykgKGZpcnN0IHBhcmFtcykpXVxuICAgIChpZiBoYXMtaW5pdGlhbFxuICAgICAgKC5yZWR1Y2UgKHZlYyBzZXF1ZW5jZSkgZiBpbml0aWFsKVxuICAgICAgKC5yZWR1Y2UgKHZlYyBzZXF1ZW5jZSkgZikpKSlcblxuKGRlZm4gY291bnRcbiAgXCJSZXR1cm5zIG51bWJlciBvZiBlbGVtZW50cyBpbiBsaXN0XCJcbiAgW3NlcXVlbmNlXVxuICAoaWYgKGFuZCBzZXF1ZW5jZSAobnVtYmVyPyAoLi1sZW5ndGggc2VxdWVuY2UpKSlcbiAgICAoLi1sZW5ndGggc2VxdWVuY2UpXG4gICAgKGxldCBbaXQgKHNlcSBzZXF1ZW5jZSldXG4gICAgICAoY29uZCAobmlsPyBpdCkgICAgICAwXG4gICAgICAgICAgICAobGF6eS1zZXE/IGl0KSAoY291bnQgKHZlYyBpdCkpXG4gICAgICAgICAgICA6ZWxzZSAgICAgICAgICAoLi1sZW5ndGggaXQpKSkpKVxuXG4oZGVmbiBlbXB0eT9cbiAgXCJSZXR1cm5zIHRydWUgaWYgbGlzdCBpcyBlbXB0eVwiXG4gIFtzZXF1ZW5jZV1cbiAgKGxldCBbaXQgKHNlcSBzZXF1ZW5jZSldXG4gICAgKGlkZW50aWNhbD8gMCAoaWYtbm90IChsYXp5LXNlcT8gaXQpXG4gICAgICAgICAgICAgICAgICAgIChjb3VudCBpdClcbiAgICAgICAgICAgICAgICAgICAgKGRvIChmaXJzdCBpdCkgICAgICAgICAgICAgOyBmb3JjaW5nIGV2YWx1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICguLWxlbmd0aCBpdCkpKSkpKVxuXG4oZGVmbiBmaXJzdFxuICBcIlJldHVybiBmaXJzdCBpdGVtIGluIGEgbGlzdFwiXG4gIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpICguLWhlYWQgc2VxdWVuY2UpXG4gICAgICAgIChvciAodmVjdG9yPyBzZXF1ZW5jZSkgKHN0cmluZz8gc2VxdWVuY2UpKSAoZ2V0IHNlcXVlbmNlIDApXG4gICAgICAgIChsYXp5LXNlcT8gc2VxdWVuY2UpIChmaXJzdCAobGF6eS1zZXEtdmFsdWUgc2VxdWVuY2UpKVxuICAgICAgICA6ZWxzZSAoZmlyc3QgKHNlcSBzZXF1ZW5jZSkpKSlcblxuKGRlZm4gc2Vjb25kXG4gIFwiUmV0dXJucyBzZWNvbmQgaXRlbSBvZiB0aGUgbGlzdFwiXG4gIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpIChmaXJzdCAocmVzdCBzZXF1ZW5jZSkpXG4gICAgICAgIChvciAodmVjdG9yPyBzZXF1ZW5jZSkgKHN0cmluZz8gc2VxdWVuY2UpKSAoZ2V0IHNlcXVlbmNlIDEpXG4gICAgICAgIChsYXp5LXNlcT8gc2VxdWVuY2UpIChzZWNvbmQgKGxhenktc2VxLXZhbHVlIHNlcXVlbmNlKSlcbiAgICAgICAgOmVsc2UgKGZpcnN0IChyZXN0IChzZXEgc2VxdWVuY2UpKSkpKVxuXG4oZGVmbiB0aGlyZFxuICBcIlJldHVybnMgdGhpcmQgaXRlbSBvZiB0aGUgbGlzdFwiXG4gIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpIChmaXJzdCAocmVzdCAocmVzdCBzZXF1ZW5jZSkpKVxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChzdHJpbmc/IHNlcXVlbmNlKSkgKGdldCBzZXF1ZW5jZSAyKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAodGhpcmQgKGxhenktc2VxLXZhbHVlIHNlcXVlbmNlKSlcbiAgICAgICAgOmVsc2UgKHNlY29uZCAocmVzdCAoc2VxIHNlcXVlbmNlKSkpKSlcblxuKGRlZm4gcmVzdFxuICBcIlJldHVybnMgbGlzdCBvZiBhbGwgaXRlbXMgZXhjZXB0IGZpcnN0IG9uZVwiXG4gIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpICcoKVxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpICguLXRhaWwgc2VxdWVuY2UpXG4gICAgICAgIChvciAodmVjdG9yPyBzZXF1ZW5jZSkgKHN0cmluZz8gc2VxdWVuY2UpKSAoLnNsaWNlIHNlcXVlbmNlIDEpXG4gICAgICAgIChsYXp5LXNlcT8gc2VxdWVuY2UpIChyZXN0IChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkpXG4gICAgICAgIDplbHNlIChyZXN0IChzZXEgc2VxdWVuY2UpKSkpXG5cbihkZWZuLSBsYXN0LW9mLWxpc3RcbiAgW2xpc3RdXG4gIChsb29wIFtpdGVtIChmaXJzdCBsaXN0KVxuICAgICAgICAgaXRlbXMgKHJlc3QgbGlzdCldXG4gICAgKGlmIChlbXB0eT8gaXRlbXMpXG4gICAgICBpdGVtXG4gICAgICAocmVjdXIgKGZpcnN0IGl0ZW1zKSAocmVzdCBpdGVtcykpKSkpXG5cbihkZWZuIGxhc3RcbiAgXCJSZXR1cm4gdGhlIGxhc3QgaXRlbSBpbiBjb2xsLCBpbiBsaW5lYXIgdGltZVwiXG4gIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG9yICh2ZWN0b3I/IHNlcXVlbmNlKVxuICAgICAgICAgICAgKHN0cmluZz8gc2VxdWVuY2UpKSAoZ2V0IHNlcXVlbmNlIChkZWMgKGNvdW50IHNlcXVlbmNlKSkpXG4gICAgICAgIChsaXN0PyBzZXF1ZW5jZSkgKGxhc3Qtb2YtbGlzdCBzZXF1ZW5jZSlcbiAgICAgICAgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAobGFzdCAobGF6eS1zZXEtdmFsdWUgc2VxdWVuY2UpKVxuICAgICAgICA6ZWxzZSAobGFzdCAoc2VxIHNlcXVlbmNlKSkpKVxuXG4oZGVmbiBidXRsYXN0XG4gIFwiUmV0dXJuIGEgc2VxIG9mIGFsbCBidXQgdGhlIGxhc3QgaXRlbSBpbiBjb2xsLCBpbiBsaW5lYXIgdGltZVwiXG4gIFtzZXF1ZW5jZV1cbiAgKGxldCBbaXRlbXMgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAgICAgICAgICAgICAoc3RyaW5nPyBzZXF1ZW5jZSkgKHN1YnMgc2VxdWVuY2UgMCAoZGVjIChjb3VudCBzZXF1ZW5jZSkpKVxuICAgICAgICAgICAgICAgICAgICAodmVjdG9yPyBzZXF1ZW5jZSkgKC5zbGljZSBzZXF1ZW5jZSAwIChkZWMgKGNvdW50IHNlcXVlbmNlKSkpXG4gICAgICAgICAgICAgICAgICAgIChsaXN0PyBzZXF1ZW5jZSkgKGFwcGx5IGxpc3QgKGJ1dGxhc3QgKHZlYyBzZXF1ZW5jZSkpKVxuICAgICAgICAgICAgICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAoYnV0bGFzdCAobGF6eS1zZXEtdmFsdWUgc2VxdWVuY2UpKVxuICAgICAgICAgICAgICAgICAgICA6ZWxzZSAoYnV0bGFzdCAoc2VxIHNlcXVlbmNlKSkpXVxuICAgIChpZi1ub3QgKGVtcHR5PyBpdGVtcykgaXRlbXMpKSlcblxuKGRlZm4gdGFrZVxuICBcIlJldHVybnMgYSBzZXF1ZW5jZSBvZiB0aGUgZmlyc3QgYG5gIGl0ZW1zLCBvciBhbGwgaXRlbXMgaWZcbiAgdGhlcmUgYXJlIGZld2VyIHRoYW4gYG5gLlwiXG4gIFtuIHNlcXVlbmNlXVxuICAoY29uZCAobmlsPyBzZXF1ZW5jZSkgJygpXG4gICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSAodGFrZS1mcm9tLXZlY3RvciBuIHNlcXVlbmNlKVxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpICh0YWtlLWZyb20tbGlzdCBuIHNlcXVlbmNlKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAoaWYgKD4gbiAwKSAodGFrZSBuIChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkpKVxuICAgICAgICA6ZWxzZSAodGFrZSBuIChzZXEgc2VxdWVuY2UpKSkpXG5cbihkZWZuIHRha2Utd2hpbGVcbiAgW3ByZWRpY2F0ZSBzZXF1ZW5jZV1cbiAgKGxvb3AgW2l0ZW1zIHNlcXVlbmNlLCByZXN1bHQgW11dXG4gICAgKGxldCBbaGVhZCAoZmlyc3QgaXRlbXMpLCB0YWlsIChyZXN0IGl0ZW1zKV1cbiAgICAgIChpZiAoYW5kIChub3QgKGVtcHR5PyBpdGVtcykpXG4gICAgICAgICAgICAgICAocHJlZGljYXRlIGhlYWQpKVxuICAgICAgICAocmVjdXIgdGFpbCAoY29uaiByZXN1bHQgaGVhZCkpXG4gICAgICAgIChpZiAobmF0aXZlPyBzZXF1ZW5jZSkgcmVzdWx0IChhcHBseSBsaXN0IHJlc3VsdCkpKSkpKVxuXG5cbihkZWZuLSB0YWtlLWZyb20tdmVjdG9yXG4gIFwiTGlrZSB0YWtlIGJ1dCBvcHRpbWl6ZWQgZm9yIHZlY3RvcnNcIlxuICBbbiB2ZWN0b3JdXG4gICguc2xpY2UgdmVjdG9yIDAgbikpXG5cbihkZWZuLSB0YWtlLWZyb20tbGlzdFxuICBcIkxpa2UgdGFrZSBidXQgZm9yIGxpc3RzXCJcbiAgW24gc2VxdWVuY2VdXG4gIChsb29wIFt0YWtlbiAnKClcbiAgICAgICAgIGl0ZW1zIHNlcXVlbmNlXG4gICAgICAgICBuICAgICAob3IgKGludCBuKSAwKV1cbiAgICAoaWYgKG9yICg8PSBuIDApIChlbXB0eT8gaXRlbXMpKVxuICAgICAgKHJldmVyc2UgdGFrZW4pXG4gICAgICAocmVjdXIgKGNvbnMgKGZpcnN0IGl0ZW1zKSB0YWtlbilcbiAgICAgICAgICAgICAocmVzdCBpdGVtcylcbiAgICAgICAgICAgICAoZGVjIG4pKSkpKVxuXG5cblxuXG4oZGVmbi0gZHJvcC1mcm9tLWxpc3QgW24gc2VxdWVuY2VdXG4gIChsb29wIFtsZWZ0IG5cbiAgICAgICAgIGl0ZW1zIHNlcXVlbmNlXVxuICAgIChpZiAob3IgKDwgbGVmdCAxKSAoZW1wdHk/IGl0ZW1zKSlcbiAgICAgIGl0ZW1zXG4gICAgICAocmVjdXIgKGRlYyBsZWZ0KSAocmVzdCBpdGVtcykpKSkpXG5cbihkZWZuIGRyb3BcbiAgW24gc2VxdWVuY2VdXG4gIChpZiAoPD0gbiAwKVxuICAgIHNlcXVlbmNlXG4gICAgKGNvbmQgKHN0cmluZz8gc2VxdWVuY2UpICguc3Vic3RyIHNlcXVlbmNlIG4pXG4gICAgICAgICAgKHZlY3Rvcj8gc2VxdWVuY2UpICguc2xpY2Ugc2VxdWVuY2UgbilcbiAgICAgICAgICAobGlzdD8gc2VxdWVuY2UpIChkcm9wLWZyb20tbGlzdCBuIHNlcXVlbmNlKVxuICAgICAgICAgIChuaWw/IHNlcXVlbmNlKSAnKClcbiAgICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAoZHJvcCBuIChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkpXG4gICAgICAgICAgOmVsc2UgKGRyb3AgbiAoc2VxIHNlcXVlbmNlKSkpKSlcblxuKGRlZm4gZHJvcC13aGlsZVxuICBbcHJlZGljYXRlIHNlcXVlbmNlXVxuICAobG9vcCBbaXRlbXMgKHNlcSBzZXF1ZW5jZSldXG4gICAgKGlmIChvciAoZW1wdHk/IGl0ZW1zKSAobm90IChwcmVkaWNhdGUgKGZpcnN0IGl0ZW1zKSkpKVxuICAgICAgaXRlbXNcbiAgICAgIChyZWN1ciAocmVzdCBpdGVtcykpKSkpXG5cblxuKGRlZm4tIGNvbmotbGlzdFxuICBbc2VxdWVuY2UgaXRlbXNdXG4gIChyZWR1Y2UgKGZuIFtyZXN1bHQgaXRlbV0gKGNvbnMgaXRlbSByZXN1bHQpKSBzZXF1ZW5jZSBpdGVtcykpXG5cbihkZWZuLSBlbnN1cmUtZGljdGlvbmFyeSBbeF1cbiAgKGlmLW5vdCAodmVjdG9yPyB4KVxuICAgIHhcbiAgICAoZGljdGlvbmFyeSAoZmlyc3QgeCkgKHNlY29uZCB4KSkpKVxuXG4oZGVmbiBjb25qXG4gIFtzZXF1ZW5jZSAmIGl0ZW1zXVxuICAoY29uZCAodmVjdG9yPyBzZXF1ZW5jZSkgKC5jb25jYXQgc2VxdWVuY2UgaXRlbXMpXG4gICAgICAgIChzdHJpbmc/IHNlcXVlbmNlKSAoc3RyIHNlcXVlbmNlIChhcHBseSBzdHIgaXRlbXMpKVxuICAgICAgICAobmlsPyBzZXF1ZW5jZSkgKGFwcGx5IGxpc3QgKHJldmVyc2UgaXRlbXMpKVxuICAgICAgICAoc2VxPyBzZXF1ZW5jZSkgKGNvbmotbGlzdCBzZXF1ZW5jZSBpdGVtcylcbiAgICAgICAgKGRpY3Rpb25hcnk/IHNlcXVlbmNlKSAobWVyZ2Ugc2VxdWVuY2UgKGFwcGx5IG1lcmdlIChtYXB2IGVuc3VyZS1kaWN0aW9uYXJ5IGl0ZW1zKSkpXG4gICAgICAgIChzZXQ/IHNlcXVlbmNlKSAoYXBwbHkgaWRlbnRpdHktc2V0IChpbnRvICh2ZWMgc2VxdWVuY2UpIGl0ZW1zKSlcbiAgICAgICAgOmVsc2UgKHRocm93IChUeXBlRXJyb3IgKHN0ciBcIlR5cGUgY2FuJ3QgYmUgY29uam9pbmVkIFwiIHNlcXVlbmNlKSkpKSlcblxuKGRlZm4gZGlzalxuICBbY29sbCAmIGtzXVxuICAobGV0IFtwcmVkaWNhdGUgKGNvbXBsZW1lbnQgKGFwcGx5IGlkZW50aXR5LXNldCBrcykpXVxuICAgIChjb25kIChlbXB0eT8ga3MpICAgICAgICBjb2xsXG4gICAgICAgICAgKHNldD8gY29sbCkgICAgICAgIChhcHBseSBpZGVudGl0eS1zZXQgKGZpbHRlcnYgcHJlZGljYXRlIGNvbGwpKVxuICAgICAgICAgIChkaWN0aW9uYXJ5PyBjb2xsKSAoaW50byB7fSAoZmlsdGVyICMocHJlZGljYXRlIChmaXJzdCAlKSkgY29sbCkpXG4gICAgICAgICAgOmVsc2UgICAgICAgICAgICAgICh0aHJvdyAoVHlwZUVycm9yIChzdHIgXCJUeXBlIGNhbid0IGJlIGRpc2pvaW5lZCBcIiBjb2xsKSkpKSkpXG5cbihkZWZuIGludG9cbiAgW3RvIGZyb21dXG4gIChhcHBseSBjb25qIHRvICh2ZWMgZnJvbSkpKVxuXG4oZGVmbiB6aXBtYXAgW2tleXMgdmFsc11cbiAgKGludG8ge30gKG1hcCB2ZWN0b3Iga2V5cyB2YWxzKSkpXG5cbihkZWZuIGFzc29jXG4gIFtzb3VyY2UgJiBrZXktdmFsdWVzXVxuICA7KGFzc2VydCAoZXZlbj8gKGNvdW50IGtleS12YWx1ZXMpKSBcIldyb25nIG51bWJlciBvZiBhcmd1bWVudHNcIilcbiAgOyhhc3NlcnQgKGFuZCAobm90IChzZXE/IHNvdXJjZSkpXG4gIDsgICAgICAgICAgICAgKG5vdCAodmVjdG9yPyBzb3VyY2UpKVxuICA7ICAgICAgICAgICAgIChvYmplY3Q/IHNvdXJjZSkpIFwiQ2FuIG9ubHkgYXNzb2Mgb24gZGljdGlvbmFyaWVzXCIpXG4gIChjb25qIHNvdXJjZSAoYXBwbHkgZGljdGlvbmFyeSBrZXktdmFsdWVzKSkpXG5cbihkZWZuIGRpc3NvY1xuICBbY29sbCAmIGtzXVxuICAoaWYgKGRpY3Rpb25hcnk/IGNvbGwpXG4gICAgKGFwcGx5IGRpc2ogY29sbCBrcylcbiAgICAodGhyb3cgKFR5cGVFcnJvciAoc3RyIFwiQ2FuIG9ubHkgZGlzc29jIG9uIGRpY3Rpb25hcmllc1wiKSkpKSlcblxuKGRlZm4gY29uY2F0XG4gIFwiUmV0dXJucyBsaXN0IHJlcHJlc2VudGluZyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgZWxlbWVudHMgaW4gdGhlXG4gIHN1cHBsaWVkIGxpc3RzLlwiXG4gIFsmIHNlcXVlbmNlc11cbiAgKHJlZHVjZSAjKGNvbmotbGlzdCAlMSAocmV2ZXJzZSAlMikpXG4gICAgICAgICAgKGxldCBbdGFpbCAobGFzdCBzZXF1ZW5jZXMpXVxuICAgICAgICAgICAgKGlmIChsYXp5LXNlcT8gdGFpbCkgdGFpbCAoYXBwbHkgbGlzdCAodmVjIHRhaWwpKSkpXG4gICAgICAgICAgKHJlc3QgKHJldmVyc2Ugc2VxdWVuY2VzKSkpKVxuXG4oZGVmbiBtYXBjYXQgW2YgJiBjb2xsc11cbiAgKGFwcGx5IGNvbmNhdCAoYXBwbHkgbWFwdiBmIGNvbGxzKSkpXG5cbihkZWZuIGVtcHR5XG4gIFwiUHJvZHVjZXMgZW1wdHkgc2VxdWVuY2Ugb2YgdGhlIHNhbWUgdHlwZSBhcyBhcmd1bWVudC5cIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChsaXN0PyBzZXF1ZW5jZSkgICAgICAgJygpXG4gICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSAgICAgW11cbiAgICAgICAgKHN0cmluZz8gc2VxdWVuY2UpICAgICBcIlwiXG4gICAgICAgIChkaWN0aW9uYXJ5PyBzZXF1ZW5jZSkge31cbiAgICAgICAgKHNldD8gc2VxdWVuY2UpICAgICAgICAje31cbiAgICAgICAgKGxhenktc2VxPyBzZXF1ZW5jZSkgICAobGF6eS1zZXEpKSlcblxuKGRlZm4gc2VxIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChzZXE/IHNlcXVlbmNlKSkgc2VxdWVuY2VcbiAgICAgICAgKHN0cmluZz8gc2VxdWVuY2UpICguY2FsbCBBcnJheS5wcm90b3R5cGUuc2xpY2Ugc2VxdWVuY2UpXG4gICAgICAgIChkaWN0aW9uYXJ5PyBzZXF1ZW5jZSkgKGtleS12YWx1ZXMgc2VxdWVuY2UpXG4gICAgICAgIChpdGVyYWJsZT8gc2VxdWVuY2UpIChpdGVyYXRvci0+bHNlcSAoKGdldCBzZXF1ZW5jZSBTeW1ib2wuaXRlcmF0b3IpKSlcbiAgICAgICAgOmRlZmF1bHQgKHRocm93IChUeXBlRXJyb3IgKHN0ciBcIkNhbiBub3Qgc2VxIFwiIHNlcXVlbmNlKSkpKSlcblxuKGRlZm4gc2VxKiBbc2VxdWVuY2VdXG4gIChsZXQgW2l0IChzZXEgc2VxdWVuY2UpXVxuICAgIChpZi1ub3QgKGVtcHR5PyBpdCkgaXQpKSlcblxuKGRlZm4gc2VxPyBbc2VxdWVuY2VdXG4gIChvciAobGlzdD8gc2VxdWVuY2UpXG4gICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSkpXG5cbihkZWZuLSBpdGVyYXRvci0+bHNlcSBbaXRlcmF0b3JdXG4gICh1bmZvbGQgIyhsZXQgW3ggKC5uZXh0ICUpXVxuICAgICAgICAgICAgIChpZi1ub3QgKC4tZG9uZSB4KSBbKC4tdmFsdWUgeCkgJV0pKVxuICAgICAgICAgIGl0ZXJhdG9yKSlcblxuKGRlZm4gdmVjXG4gIFwiQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgY29udGFpbmluZyB0aGUgY29udGVudHMgb2Ygc2VxdWVuY2VcIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChuaWw/IHNlcXVlbmNlKSBbXVxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChsaXN0PyBzZXF1ZW5jZSkpIChBcnJheS5mcm9tIHNlcXVlbmNlKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAobGV0IFt4cyAoQXJyYXkuZnJvbSBzZXF1ZW5jZSldICAgICAgICAgICAgOyBvcHRpbWl6aW5nIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldCEgKC4tbGVuZ3RoIHNlcXVlbmNlKSAoLi1sZW5ndGggeHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhzKVxuICAgICAgICA6ZWxzZSAodmVjIChzZXEgc2VxdWVuY2UpKSkpXG5cbihkZWZuIHZlY3RvciBbJiBzZXF1ZW5jZV0gc2VxdWVuY2UpXG5cbihkZWYgXns6cHJpdmF0ZSB0cnVlfVxuICBzb3J0LWNvbXBhcmF0b3JcbiAgKGlmICg9IFsxIDIgM10gKC5zb3J0IFsyIDEgM10gKGZuIFthIGJdIChpZiAoPCBhIGIpIDAgMSkpKSlcbiAgICAjKGZuIFthIGJdIChpZiAoJSBiIGEpICAxIDApKSAgICAgICA7IHF1aWNrc29ydCAoQ2hyb21lLCBOb2RlKSwgbWVyZ2Vzb3J0IChGaXJlZm94KVxuICAgICMoZm4gW2EgYl0gKGlmICglIGEgYikgLTEgMCkpKSkgICAgIDsgdGltc29ydCAoQ2hyb21lIDcwKywgTm9kZSAxMSspXG5cbihkZWZuIHNvcnRcbiAgXCJSZXR1cm5zIGEgc29ydGVkIHNlcXVlbmNlIG9mIHRoZSBpdGVtcyBpbiBjb2xsLlxuICBJZiBubyBjb21wYXJhdG9yIGlzIHN1cHBsaWVkLCB1c2VzIGNvbXBhcmUuXCJcbiAgW2YgaXRlbXNdXG4gIChsZXQgW2hhcy1jb21wYXJhdG9yIChmbj8gZilcbiAgICAgICAgaXRlbXMgICAgICAgICAgKGlmIChhbmQgKG5vdCBoYXMtY29tcGFyYXRvcikgKG5pbD8gaXRlbXMpKSBmIGl0ZW1zKVxuICAgICAgICBjb21wYXJlICAgICAgICAoaWYgaGFzLWNvbXBhcmF0b3IgKHNvcnQtY29tcGFyYXRvciBmKSlcbiAgICAgICAgcmVzdWx0ICAgICAgICAgKC5zb3J0ICh2ZWMgaXRlbXMpIGNvbXBhcmUpXVxuICAgIChjb25kIChuaWw/IGl0ZW1zKSAgICAnKClcbiAgICAgICAgICAodmVjdG9yPyBpdGVtcykgcmVzdWx0XG4gICAgICAgICAgOmVsc2UgICAgICAgICAgIChhcHBseSBsaXN0IHJlc3VsdCkpKSlcblxuXG4oZGVmbiByZXBlYXRlZGx5XG4gIFwiVGFrZXMgYSBmdW5jdGlvbiBvZiBubyBhcmdzLCBwcmVzdW1hYmx5IHdpdGggc2lkZSBlZmZlY3RzLCBhbmRcbiAgcmV0dXJucyB2ZWN0b3Igb2YgZ2l2ZW4gYG5gIGxlbmd0aCB3aXRoIGNhbGxzIHRvIGl0XCJcbiAgW24gZl1cbiAgKEFycmF5LmZyb20gezpsZW5ndGggbn0gZikpXG5cbihkZWZuIHJlcGVhdFxuICBcIlJldHVybnMgYSB2ZWN0b3Igb2YgZ2l2ZW4gYG5gIGxlbmd0aCB3aXRoIGdpdmVuIGB4YFxuICBpdGVtcy4gTm90IGNvbXBhdGlibGUgd2l0aCBjbG9qdXJlIGFzIGl0J3Mgbm90IGEgbGF6eVxuICBhbmQgb25seSBmaW5pdGUgcmVwZWF0cyBhcmUgc3VwcG9ydGVkXCJcbiAgW24geF1cbiAgKHJlcGVhdGVkbHkgbiAoZm4gW10geCkpKVxuXG5cbihkZWZuIGV2ZXJ5P1xuICBbcHJlZGljYXRlIHNlcXVlbmNlXVxuICAoLmV2ZXJ5ICh2ZWMgc2VxdWVuY2UpICMocHJlZGljYXRlICUpKSlcblxuKGRlZm4gc29tZVxuICBcIlJldHVybnMgdGhlIGZpcnN0IGxvZ2ljYWwgdHJ1ZSB2YWx1ZSBvZiAocHJlZCB4KSBmb3IgYW55IHggaW4gY29sbCxcbiAgZWxzZSBuaWwuICBPbmUgY29tbW9uIGlkaW9tIGlzIHRvIHVzZSBhIHNldCBhcyBwcmVkLCBmb3IgZXhhbXBsZVxuICB0aGlzIHdpbGwgcmV0dXJuIDpmcmVkIGlmIDpmcmVkIGlzIGluIHRoZSBzZXF1ZW5jZSwgb3RoZXJ3aXNlIG5pbDpcbiAgKHNvbWUgI3s6ZnJlZH0gY29sbClcIlxuICBbcHJlZCBjb2xsXVxuICAobG9vcCBbaXRlbXMgKHNlcSBjb2xsKV1cbiAgICAoaWYtbm90IChlbXB0eT8gaXRlbXMpXG4gICAgICAob3IgKHByZWQgKGZpcnN0IGl0ZW1zKSkgKHJlY3VyIChyZXN0IGl0ZW1zKSkpKSkpXG5cblxuKGRlZm4gcGFydGl0aW9uXG4gIChbbiBjb2xsXSAocGFydGl0aW9uIG4gbiBjb2xsKSlcbiAgKFtuIHN0ZXAgY29sbF0gKHBhcnRpdGlvbiBuIHN0ZXAgW10gY29sbCkpXG4gIChbbiBzdGVwIHBhZCBjb2xsXVxuICAgKGxvb3AgW3Jlc3VsdCBbXVxuICAgICAgICAgIGl0ZW1zIChzZXEgY29sbCldXG4gICAgIChsZXQgW2NodW5rICh0YWtlIG4gaXRlbXMpXG4gICAgICAgICAgIHNpemUgKGNvdW50IGNodW5rKV1cbiAgICAgICAoY29uZCAoaWRlbnRpY2FsPyBzaXplIG4pIChyZWN1ciAoY29uaiByZXN1bHQgY2h1bmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyb3Agc3RlcCBpdGVtcykpXG4gICAgICAgICAgICAgKGlkZW50aWNhbD8gMCBzaXplKSByZXN1bHRcbiAgICAgICAgICAgICAoPiBuICgrIHNpemUgKGNvdW50IHBhZCkpKSByZXN1bHRcbiAgICAgICAgICAgICA6ZWxzZSAoY29uaiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGFrZSBuICh2ZWMgKGNvbmNhdCBjaHVua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZCkpKSkpKSkpKVxuXG4oZGVmbiBpbnRlcmxlYXZlIFsmIHNlcXVlbmNlc11cbiAgKGlmIChlbXB0eT8gc2VxdWVuY2VzKVxuICAgIFtdXG4gICAgKGxvb3AgW3Jlc3VsdCBbXVxuICAgICAgICAgICBzZXF1ZW5jZXMgc2VxdWVuY2VzXVxuICAgICAgKGlmIChzb21lIGVtcHR5PyBzZXF1ZW5jZXMpXG4gICAgICAgICh2ZWMgcmVzdWx0KVxuICAgICAgICAocmVjdXIgKGNvbmNhdCByZXN1bHQgKG1hcCBmaXJzdCBzZXF1ZW5jZXMpKVxuICAgICAgICAgICAgICAgKG1hcCByZXN0IHNlcXVlbmNlcykpKSkpKVxuXG4oZGVmbiBudGhcbiAgXCJSZXR1cm5zIG50aCBpdGVtIG9mIHRoZSBzZXF1ZW5jZVwiXG4gIFtzZXF1ZW5jZSBpbmRleCBub3QtZm91bmRdXG4gIChsZXQgW3NlcXVlbmNlIChzZXEqIHNlcXVlbmNlKV1cbiAgICAoY29uZCAobmlsPyBzZXF1ZW5jZSkgbm90LWZvdW5kXG4gICAgICAgICAgKHNlcT8gc2VxdWVuY2UpIChpZi1sZXQgW2l0IChzZXEqIChkcm9wIGluZGV4IHNlcXVlbmNlKSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpcnN0IGl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdC1mb3VuZClcbiAgICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpXG4gICAgICAgICAgICAgIChzdHJpbmc/IHNlcXVlbmNlKSkgKGlmICg8IGluZGV4IChjb3VudCBzZXF1ZW5jZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWdldCBzZXF1ZW5jZSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdC1mb3VuZClcbiAgICAgICAgICA6ZWxzZSAodGhyb3cgKFR5cGVFcnJvciBcIlVuc3VwcG9ydGVkIHR5cGVcIikpKSkpXG5cblxuKGRlZm4gY29udGFpbnM/XG4gIFwiUmV0dXJucyB0cnVlIGlmIGtleSBpcyBwcmVzZW50IGluIHRoZSBnaXZlbiBjb2xsZWN0aW9uLCBvdGhlcndpc2VcbiAgcmV0dXJucyBmYWxzZS4gIE5vdGUgdGhhdCBmb3IgbnVtZXJpY2FsbHkgaW5kZXhlZCBjb2xsZWN0aW9ucyBsaWtlXG4gIHZlY3RvcnMgYW5kIHN0cmluZ3MsIHRoaXMgdGVzdHMgaWYgdGhlIG51bWVyaWMga2V5IGlzIHdpdGhpbiB0aGVcbiAgcmFuZ2Ugb2YgaW5kZXhlcy4gJ2NvbnRhaW5zPycgb3BlcmF0ZXMgY29uc3RhbnQgb3IgbG9nYXJpdGhtaWMgdGltZTtcbiAgaXQgd2lsbCBub3QgcGVyZm9ybSBhIGxpbmVhciBzZWFyY2ggZm9yIGEgdmFsdWUuICBTZWUgYWxzbyAnc29tZScuXCJcbiAgW2NvbGwgdl1cbiAgKGNvbmQgKHNldD8gY29sbCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKC5oYXMgY29sbCB2KVxuICAgICAgICAob3IgKGRpY3Rpb25hcnk/IGNvbGwpICh2ZWN0b3I/IGNvbGwpIChzdHJpbmc/IGNvbGwpKSAoLmhhcy1vd24tcHJvcGVydHkgY29sbCB2KVxuICAgICAgICA6ZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSkpXG5cbihkZWZuIHVuaW9uXG4gIFwiUmV0dXJuIGEgc2V0IHRoYXQgaXMgdGhlIHVuaW9uIG9mIHRoZSBpbnB1dCBzZXRzXCJcbiAgWyYgc2V0c11cbiAgKGludG8gI3t9IChhcHBseSBjb25jYXQgc2V0cykpKVxuXG4oZGVmbiBkaWZmZXJlbmNlXG4gIFwiUmV0dXJuIGEgc2V0IHRoYXQgaXMgdGhlIGZpcnN0IHNldCB3aXRob3V0IGVsZW1lbnRzIG9mIHRoZSByZW1haW5pbmcgc2V0c1wiXG4gIFtzMSAmIHNldHNdXG4gIChpbnRvICN7fSAoZmlsdGVyIChjb21wbGVtZW50IChhcHBseSB1bmlvbiBzZXRzKSlcbiAgICAgICAgICAgICAgICAgICAgczEpKSlcblxuKGRlZm4gaW50ZXJzZWN0aW9uXG4gIFwiUmV0dXJuIGEgc2V0IHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgaW5wdXQgc2V0c1wiXG4gIFsmIHNldHNdXG4gIChsZXQgW3NldHMgICAgIChtYXB2ICMoaW50byAje30gJSkgc2V0cylcbiAgICAgICAgaW4tZWFjaD8gKGZuIFt4XSAoZXZlcnk/ICMoLmhhcyAlIHgpIHNldHMpKVxuICAgICAgICBtaW4tc2l6ZSAoYXBwbHkgbWluIChtYXB2IGNvdW50IHNldHMpKVxuICAgICAgICBzbWFsbGVzdCAoLmZpbmQgc2V0cyAjKD0gbWluLXNpemUgKGNvdW50ICUpKSldXG4gICAgKGludG8gI3t9IChmaWx0ZXIgaW4tZWFjaD8gc21hbGxlc3QpKSkpXG5cbihkZWZuIHN1YnNldD9cbiAgXCJJcyBzZXQxIGEgc3Vic2V0IG9mIHNldDI/XCJcbiAgW3NldDEgc2V0Ml1cbiAgKGlmIChzZXQ/IHNldDIpXG4gICAgKGV2ZXJ5PyAjKC5oYXMgc2V0MiAlKSBzZXQxKVxuICAgIChzdWJzZXQ/IHNldDEgKGludG8gI3t9IHNldDIpKSkpXG5cbihkZWZuIHN1cGVyc2V0P1xuICBcIklzIHNldDEgYSBzdXBlcnNldCBvZiBzZXQyP1wiXG4gIFtzZXQxIHNldDJdXG4gIChzdWJzZXQ/IHNldDIgc2V0MSkpXG5cblxuKGRlZm4gdW5mb2xkXG4gIFwiUmV0dXJucyBhIGxhenkgc2VxdWVuY2U7IChmIHgpIGlzIGV4cGVjdGVkIHRvIHJldHVybiBlaXRoZXIgbmlsIChzaWduaWZ5aW5nIGVuZCBvZiBzZXF1ZW5jZSlcbiAgb3IgW3kgeDFdICh3aGVyZSB5IGlzIG5leHQgc2VxdWVuY2UgaXRlbSwgYW5kIHgxIGlzIG5leHQgdmFsdWUgb2YgeClcIlxuICBbZiB4XVxuICAobGF6eS1zZXEgKGlmLWxldCBbbmV4dCAoZiB4KV1cbiAgICAgICAgICAgICAgKGNvbnMgKGZpcnN0IG5leHQpICh1bmZvbGQgZiAoc2Vjb25kIG5leHQpKSkpKSlcblxuKGRlZm4gaXRlcmF0ZVxuICBcIlJldHVybnMgYSBsYXp5IHNlcXVlbmNlIG9mIHgsIChmIHgpLCAoZiAoZiB4KSkgZXRjLiBmIG11c3QgYmUgZnJlZSBvZiBzaWRlLWVmZmVjdHNcIlxuICBbZiB4XVxuICAobGF6eS1zZXEgKGNvbnMgeCAoaXRlcmF0ZSBmIChmIHgpKSkpKVxuXG4oZGVmbiBjeWNsZVxuICBcIlJldHVybnMgYSBsYXp5IChpbmZpbml0ZSEpIHNlcXVlbmNlIG9mIHJlcGV0aXRpb25zIG9mIHRoZSBpdGVtcyBpbiBjb2xsLlwiXG4gIFtjb2xsXVxuICAobGF6eS1zZXEgKGlmLW5vdCAoZW1wdHk/IGNvbGwpXG4gICAgICAgICAgICAgIChjb25jYXQgY29sbCAoY3ljbGUgY29sbCkpKSkpXG5cbihkZWZuIGluZmluaXRlLXJhbmdlXG4gIChbXSAoaW5maW5pdGUtcmFuZ2UgMCkpXG4gIChbbl0gKGl0ZXJhdGUgaW5jIG4pKVxuICAoW24gc3RlcF0gKGl0ZXJhdGUgIygrICUgc3RlcCkgbikpKVxuXG4oZGVmbiBsYXp5LW1hcCBbZiAmIHNlcXVlbmNlc11cbiAgKHVuZm9sZCAjKGlmLW5vdCAoc29tZSBlbXB0eT8gJSlcbiAgICAgICAgICAgICBbKGFwcGx5IGYgKG1hcHYgZmlyc3QgJSkpIChtYXB2IHJlc3QgJSldKVxuICAgICAgICAgIHNlcXVlbmNlcykpXG5cbihkZWZuIGxhenktZmlsdGVyIFtmIHNlcXVlbmNlXVxuICAodW5mb2xkICMobG9vcCBbeHMgJV1cbiAgICAgICAgICAgICAoY29uZCAoZW1wdHk/IHhzKSAgICBuaWxcbiAgICAgICAgICAgICAgICAgICAoZiAoZmlyc3QgeHMpKSBbKGZpcnN0IHhzKSAocmVzdCB4cyldXG4gICAgICAgICAgICAgICAgICAgOmVsc2UgICAgICAgICAgKHJlY3VyIChyZXN0IHhzKSkpKVxuICAgICAgICAgIChzZXEgc2VxdWVuY2UpKSlcblxuKGRlZm4gbGF6eS1jb25jYXQgWyYgc2VxdWVuY2VzXVxuICAoaWYtbm90IChlbXB0eT8gc2VxdWVuY2VzKVxuICAgICgoZm4gaXRlciBbeHNdXG4gICAgICAgKGxhenktc2VxIChpZiAoZW1wdHk/IHhzKVxuICAgICAgICAgICAgICAgICAgIChhcHBseSBsYXp5LWNvbmNhdCAocmVzdCBzZXF1ZW5jZXMpKVxuICAgICAgICAgICAgICAgICAgIChjb25zIChmaXJzdCB4cykgKGl0ZXIgKHJlc3QgeHMpKSkpKSlcbiAgICAgKHNlcSAoZmlyc3Qgc2VxdWVuY2VzKSkpKSlcblxuKGRlZm4gbGF6eS1wYXJ0aXRpb25cbiAgKFtuIGNvbGxdIChsYXp5LXBhcnRpdGlvbiBuIG4gY29sbCkpXG4gIChbbiBzdGVwIGNvbGxdIChsYXp5LXBhcnRpdGlvbiBuIHN0ZXAgW10gY29sbCkpXG4gIChbbiBzdGVwIHBhZCBjb2xsXVxuICAgICh1bmZvbGQgIyhsZXQgW2NodW5rICh0YWtlIG4gKGNvbmNhdCAodGFrZSBuICUpIHBhZCkpXVxuICAgICAgICAgICAgICAgKGlmIChhbmQgKG5vdCAoZW1wdHk/ICUpKSAoaWRlbnRpY2FsPyBuIChjb3VudCBjaHVuaykpKVxuICAgICAgICAgICAgICAgICBbY2h1bmsgKGRyb3Agc3RlcCAlKV0pKVxuICAgICAgICAgICAgY29sbCkpKVxuXG5cbihkZWZuIHJ1biFcbiAgXCJSdW5zIHRoZSBzdXBwbGllZCBwcm9jZWR1cmUgKHZpYSByZWR1Y2UpLCBmb3IgcHVycG9zZXMgb2Ygc2lkZVxuICBlZmZlY3RzLCBvbiBzdWNjZXNzaXZlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLiBSZXR1cm5zIG5pbFwiXG4gIFtwcm9jIGNvbGxdXG4gIChyZWR1Y2UgKGZuIFtfIHhdIChwcm9jIHgpIG5pbCkgbmlsIGNvbGwpKVxuXG4oZGVmbiBkb3J1blxuICBcIldoZW4gbGF6eSBzZXF1ZW5jZXMgYXJlIHByb2R1Y2VkIHZpYSBmdW5jdGlvbnMgdGhhdCBoYXZlIHNpZGVcbiAgZWZmZWN0cywgYW55IGVmZmVjdHMgb3RoZXIgdGhhbiB0aG9zZSBuZWVkZWQgdG8gcHJvZHVjZSB0aGUgZmlyc3RcbiAgZWxlbWVudCBpbiB0aGUgc2VxIGRvIG5vdCBvY2N1ciB1bnRpbCB0aGUgc2VxIGlzIGNvbnN1bWVkLiBkb3J1biBjYW5cbiAgYmUgdXNlZCB0byBmb3JjZSBhbnkgZWZmZWN0cy4gV2Fsa3MgdGhyb3VnaCB0aGUgc3VjY2Vzc2l2ZSBuZXh0cyBvZlxuICB0aGUgc2VxLCBkb2VzIG5vdCByZXRhaW4gdGhlIGhlYWQgYW5kIHJldHVybnMgbmlsLlwiXG4gIChbY29sbF0gKGRvcnVuIEluZmluaXR5IGNvbGwpKVxuICAoW24gY29sbF0gKHJ1biEgaWRlbnRpdHkgKHRha2UgbiBjb2xsKSkpKVxuXG4oZGVmbiBkb2FsbFxuICBcIldoZW4gbGF6eSBzZXF1ZW5jZXMgYXJlIHByb2R1Y2VkIHZpYSBmdW5jdGlvbnMgdGhhdCBoYXZlIHNpZGVcbiAgZWZmZWN0cywgYW55IGVmZmVjdHMgb3RoZXIgdGhhbiB0aG9zZSBuZWVkZWQgdG8gcHJvZHVjZSB0aGUgZmlyc3RcbiAgZWxlbWVudCBpbiB0aGUgc2VxIGRvIG5vdCBvY2N1ciB1bnRpbCB0aGUgc2VxIGlzIGNvbnN1bWVkLiBkb3J1biBjYW5cbiAgYmUgdXNlZCB0byBmb3JjZSBhbnkgZWZmZWN0cy4gV2Fsa3MgdGhyb3VnaCB0aGUgc3VjY2Vzc2l2ZSBuZXh0cyBvZlxuICB0aGUgc2VxLCByZXRhaW5zIHRoZSBoZWFkIGFuZCByZXR1cm5zIGl0LCB0aHVzIGNhdXNpbmcgdGhlIGVudGlyZVxuICBzZXEgdG8gcmVzaWRlIGluIG1lbW9yeSBhdCBvbmUgdGltZS5cIlxuICAoW2NvbGxdIChkb2FsbCBJbmZpbml0eSBjb2xsKSlcbiAgKFtuIGNvbGxdIChkb3J1biBuIGNvbGwpIGNvbGwpKVxuIl19
