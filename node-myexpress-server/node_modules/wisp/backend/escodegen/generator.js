{
    var _ns_ = {
            id: 'wisp.backend.escodegen.generator',
            doc: void 0
        };
    var wisp_reader = require('./../../reader');
    var readString = wisp_reader.readFromString;
    var read_ = wisp_reader.read_;
    var wisp_ast = require('./../../ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var namespace = wisp_ast.namespace;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var isQuote = wisp_ast.isQuote;
    var isSyntaxQuote = wisp_ast.isSyntaxQuote;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var prStr = wisp_ast.prStr;
    var wisp_sequence = require('./../../sequence');
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var butlast = wisp_sequence.butlast;
    var reverse = wisp_sequence.reverse;
    var reduce = wisp_sequence.reduce;
    var vec = wisp_sequence.vec;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var filter = wisp_sequence.filter;
    var take = wisp_sequence.take;
    var concat = wisp_sequence.concat;
    var partition = wisp_sequence.partition;
    var repeat = wisp_sequence.repeat;
    var interleave = wisp_sequence.interleave;
    var wisp_runtime = require('./../../runtime');
    var isOdd = wisp_runtime.isOdd;
    var isDictionary = wisp_runtime.isDictionary;
    var dictionary = wisp_runtime.dictionary;
    var merge = wisp_runtime.merge;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isContainsVector = wisp_runtime.isContainsVector;
    var mapDictionary = wisp_runtime.mapDictionary;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isBoolean = wisp_runtime.isBoolean;
    var subs = wisp_runtime.subs;
    var reFind = wisp_runtime.reFind;
    var isTrue = wisp_runtime.isTrue;
    var isFalse = wisp_runtime.isFalse;
    var isNil = wisp_runtime.isNil;
    var isRePattern = wisp_runtime.isRePattern;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var str = wisp_runtime.str;
    var char = wisp_runtime.char;
    var int = wisp_runtime.int;
    var isEqual = wisp_runtime.isEqual;
    var isStrictEqual = wisp_runtime.isStrictEqual;
    var wisp_string = require('./../../string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var upperCase = wisp_string.upperCase;
    var replace = wisp_string.replace;
    var wisp_expander = require('./../../expander');
    var installMacro = wisp_expander.installMacro;
    var wisp_analyzer = require('./../../analyzer');
    var emptyEnv = wisp_analyzer.emptyEnv;
    var analyze = wisp_analyzer.analyze;
    var analyze_ = wisp_analyzer.analyze_;
    var wisp_backend_escodegen_writer = require('./writer');
    var write = wisp_backend_escodegen_writer.write;
    var compile = wisp_backend_escodegen_writer.compile;
    var write_ = wisp_backend_escodegen_writer.write_;
    var escodegen = require('escodegen');
    var generate_ = escodegen.generate;
    var base64Encode = require('base64-encode');
    var btoa = base64Encode;
    var fs = require('fs');
    var readFileSync = fs.readFileSync;
    var writeFileSync = fs.writeFileSync;
    var path = require('path');
    var basename = path.basename;
    var dirname = path.dirname;
    var joinPath = path.join;
}
var generate = exports.generate = function generate(options) {
        var nodes = Array.prototype.slice.call(arguments, 1);
        return function () {
            var astø1 = write_.apply(void 0, nodes);
            var outputø1 = generate_(astø1, {
                    'file': (options || 0)['output-uri'],
                    'sourceContent': (options || 0)['source'],
                    'sourceMap': (options || 0)['source-uri'],
                    'sourceMapRoot': (options || 0)['source-root'],
                    'sourceMapWithCode': true
                });
            (outputø1 || 0)['map'].setSourceContent((options || 0)['source-uri'], (options || 0)['source']);
            return {
                'code': (options || 0)['no-map'] ? (outputø1 || 0)['code'] : '' + (outputø1 || 0)['code'] + '\n//# sourceMappingURL=' + 'data:application/json;base64,' + btoa('' + (outputø1 || 0)['map']) + '\n',
                'source-map': (outputø1 || 0)['map'],
                'js-ast': astø1
            };
        }.call(this);
    };
var expandDefmacro = exports.expandDefmacro = function expandDefmacro(_andForm, id) {
        var body = Array.prototype.slice.call(arguments, 2);
        return function () {
            var fnø1 = withMeta(list.apply(void 0, [symbol(void 0, 'defn')].concat([id], vec(body))), meta(_andForm));
            var formø1 = list.apply(void 0, [symbol(void 0, 'do')].concat([fnø1], [id]));
            var astø1 = analyze(formø1);
            var codeø1 = compile(astø1);
            var macroø1 = eval(codeø1);
            installMacro(id, macroø1);
            return void 0;
        }.call(this);
    };
installMacro(symbol(void 0, 'defmacro'), withMeta(expandDefmacro, { 'implicit': ['&form'] }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsInJlYWRTdHJpbmciLCJyZWFkRnJvbVN0cmluZyIsInJlYWRfIiwibWV0YSIsIndpdGhNZXRhIiwiaXNTeW1ib2wiLCJzeW1ib2wiLCJpc0tleXdvcmQiLCJrZXl3b3JkIiwibmFtZXNwYWNlIiwiaXNVbnF1b3RlIiwiaXNVbnF1b3RlU3BsaWNpbmciLCJpc1F1b3RlIiwiaXNTeW50YXhRdW90ZSIsIm5hbWUiLCJnZW5zeW0iLCJwclN0ciIsImlzRW1wdHkiLCJjb3VudCIsImlzTGlzdCIsImxpc3QiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsImNvbnMiLCJjb25qIiwiYnV0bGFzdCIsInJldmVyc2UiLCJyZWR1Y2UiLCJ2ZWMiLCJsYXN0IiwibWFwIiwiZmlsdGVyIiwidGFrZSIsImNvbmNhdCIsInBhcnRpdGlvbiIsInJlcGVhdCIsImludGVybGVhdmUiLCJpc09kZCIsImlzRGljdGlvbmFyeSIsImRpY3Rpb25hcnkiLCJtZXJnZSIsImtleXMiLCJ2YWxzIiwiaXNDb250YWluc1ZlY3RvciIsIm1hcERpY3Rpb25hcnkiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNWZWN0b3IiLCJpc0Jvb2xlYW4iLCJzdWJzIiwicmVGaW5kIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzTmlsIiwiaXNSZVBhdHRlcm4iLCJpbmMiLCJkZWMiLCJzdHIiLCJjaGFyIiwiaW50IiwiaXNFcXVhbCIsImlzU3RyaWN0RXF1YWwiLCJzcGxpdCIsImpvaW4iLCJ1cHBlckNhc2UiLCJyZXBsYWNlIiwiaW5zdGFsbE1hY3JvIiwiZW1wdHlFbnYiLCJhbmFseXplIiwiYW5hbHl6ZV8iLCJ3cml0ZSIsImNvbXBpbGUiLCJ3cml0ZV8iLCJnZW5lcmF0ZV8iLCJnZW5lcmF0ZSIsInJlYWRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJqb2luUGF0aCIsImV4cG9ydHMiLCJvcHRpb25zIiwibm9kZXMiLCJhc3TDuDEiLCJvdXRwdXTDuDEiLCJzZXRTb3VyY2VDb250ZW50IiwiYnRvYSIsImV4cGFuZERlZm1hY3JvIiwiX2FuZEZvcm0iLCJib2R5IiwiZm7DuDEiLCJmb3Jtw7gxIiwiY29kZcO4MSIsIm1hY3Jvw7gxIiwiZXZhbCJdLCJtYXBwaW5ncyI6IjtJQUFBLElBQUNBLEksR0FBRDtBQUFBLFlBQUFDLEUsRUFBSSxrQ0FBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUVtREMsVUFBQSxHLFlBRGxCQyxjO1FBQWlCQyxLQUFBLEcsWUFBQUEsSzs7UUFFcEJDLElBQUEsRyxTQUFBQSxJO1FBQUtDLFFBQUEsRyxTQUFBQSxRO1FBQVVDLFFBQUEsRyxTQUFBQSxRO1FBQVFDLE1BQUEsRyxTQUFBQSxNO1FBQU9DLFNBQUEsRyxTQUFBQSxTO1FBQVNDLE9BQUEsRyxTQUFBQSxPO1FBQ3ZDQyxTQUFBLEcsU0FBQUEsUztRQUFVQyxTQUFBLEcsU0FBQUEsUztRQUFTQyxpQkFBQSxHLFNBQUFBLGlCO1FBQWtCQyxPQUFBLEcsU0FBQUEsTztRQUNyQ0MsYUFBQSxHLFNBQUFBLGE7UUFBY0MsSUFBQSxHLFNBQUFBLEk7UUFBS0MsTUFBQSxHLFNBQUFBLE07UUFBT0MsS0FBQSxHLFNBQUFBLEs7O1FBQ3JCQyxPQUFBLEcsY0FBQUEsTztRQUFPQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxNQUFBLEcsY0FBQUEsTTtRQUFNQyxJQUFBLEcsY0FBQUEsSTtRQUFLQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxNQUFBLEcsY0FBQUEsTTtRQUFPQyxLQUFBLEcsY0FBQUEsSztRQUNyQ0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsT0FBQSxHLGNBQUFBLE87UUFBUUMsT0FBQSxHLGNBQUFBLE87UUFBUUMsTUFBQSxHLGNBQUFBLE07UUFBT0MsR0FBQSxHLGNBQUFBLEc7UUFDdENDLElBQUEsRyxj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LElBQU1JLGNBQUEsR0FBQVAsT0FBQSxDQUFBTyxjQUFBLEdBQU4sU0FBTUEsY0FBTixDQUlHQyxRQUpILEVBSVM1RixFQUpULEU7WUFJYzZGLElBQUEsRztRQUNaLE87WUFBTSxJQUFBQyxJLEdBQUl4RixRQUFELEMsVUFBVyxDLE1BQUEsRSxPQUFFLEMsTUFBQSxFLE1BQUEsQyxVQUFNTixFLE9BQUs2RixJLEVBQWIsQ0FBWCxFQUErQnhGLElBQUQsQ0FBTXVGLFFBQU4sQ0FBOUIsQ0FBSCxDO1lBQ0EsSUFBQUcsTSxhQUFLLEMsTUFBQSxFLE9BQUUsQyxNQUFBLEUsSUFBQSxDLFVBQUlELEksSUFBSTlGLEUsRUFBVixDQUFMLEM7WUFDQSxJQUFBdUYsSyxHQUFLZixPQUFELENBQVN1QixNQUFULENBQUosQztZQUNBLElBQUFDLE0sR0FBTXJCLE9BQUQsQ0FBU1ksS0FBVCxDQUFMLEM7WUFDQSxJQUFBVSxPLEdBQU9DLElBQUQsQ0FBTUYsTUFBTixDQUFOLEM7WUFDSDFCLFlBQUQsQ0FBZ0J0RSxFQUFoQixFQUFtQmlHLE9BQW5CLEU7O2NBTEYsQyxJQUFBLEU7S0FMRixDO0FBWUMzQixZQUFELEMsTUFBaUIsQyxNQUFBLEUsVUFBQSxDQUFqQixFQUEyQmhFLFFBQUQsQ0FBV3FGLGNBQVgsRUFBMkIsRSxZQUFXLEMsT0FBQSxDQUFYLEVBQTNCLENBQTFCIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AuYmFja2VuZC5lc2NvZGVnZW4uZ2VuZXJhdG9yXG4gICg6cmVxdWlyZSBbd2lzcC5yZWFkZXIgOnJlZmVyIFtyZWFkLWZyb20tc3RyaW5nIHJlYWQqXVxuICAgICAgICAgICAgICAgICAgICAgICAgIDpyZW5hbWUge3JlYWQtZnJvbS1zdHJpbmcgcmVhZC1zdHJpbmd9XVxuICAgICAgICAgICAgW3dpc3AuYXN0IDpyZWZlciBbbWV0YSB3aXRoLW1ldGEgc3ltYm9sPyBzeW1ib2wga2V5d29yZD8ga2V5d29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlIHVucXVvdGU/IHVucXVvdGUtc3BsaWNpbmc/IHF1b3RlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ludGF4LXF1b3RlPyBuYW1lIGdlbnN5bSBwci1zdHJdXVxuICAgICAgICAgICAgW3dpc3Auc2VxdWVuY2UgOnJlZmVyIFtlbXB0eT8gY291bnQgbGlzdD8gbGlzdCBmaXJzdCBzZWNvbmQgdGhpcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCBjb25zIGNvbmogYnV0bGFzdCByZXZlcnNlIHJlZHVjZSB2ZWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCBtYXAgZmlsdGVyIHRha2UgY29uY2F0IHBhcnRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgaW50ZXJsZWF2ZV1dXG4gICAgICAgICAgICBbd2lzcC5ydW50aW1lIDpyZWZlciBbb2RkPyBkaWN0aW9uYXJ5PyBkaWN0aW9uYXJ5IG1lcmdlIGtleXMgdmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zLXZlY3Rvcj8gbWFwLWRpY3Rpb25hcnkgc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcj8gdmVjdG9yPyBib29sZWFuPyBzdWJzIHJlLWZpbmQgdHJ1ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZT8gbmlsPyByZS1wYXR0ZXJuPyBpbmMgZGVjIHN0ciBjaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ID0gPT1dXVxuICAgICAgICAgICAgW3dpc3Auc3RyaW5nIDpyZWZlciBbc3BsaXQgam9pbiB1cHBlci1jYXNlIHJlcGxhY2VdXVxuICAgICAgICAgICAgW3dpc3AuZXhwYW5kZXIgOnJlZmVyIFtpbnN0YWxsLW1hY3JvIV1dXG4gICAgICAgICAgICBbd2lzcC5hbmFseXplciA6cmVmZXIgW2VtcHR5LWVudiBhbmFseXplIGFuYWx5emUqXV1cbiAgICAgICAgICAgIFt3aXNwLmJhY2tlbmQuZXNjb2RlZ2VuLndyaXRlciA6cmVmZXIgW3dyaXRlIGNvbXBpbGUgd3JpdGUqXV1cblxuICAgICAgICAgICAgW2VzY29kZWdlbiA6cmVmZXIgW2dlbmVyYXRlXSA6cmVuYW1lIHtnZW5lcmF0ZSBnZW5lcmF0ZSp9XVxuICAgICAgICAgICAgW2Jhc2U2NC1lbmNvZGUgOmFzIGJ0b2FdXG4gICAgICAgICAgICBbZnMgOnJlZmVyIFtyZWFkLWZpbGUtc3luYyB3cml0ZS1maWxlLXN5bmNdXVxuICAgICAgICAgICAgW3BhdGggOnJlZmVyIFtiYXNlbmFtZSBkaXJuYW1lIGpvaW5dXG4gICAgICAgICAgICAgICAgICA6cmVuYW1lIHtqb2luIGpvaW4tcGF0aH1dKSlcblxuKGRlZm4gZ2VuZXJhdGVcbiAgW29wdGlvbnMgJiBub2Rlc11cbiAgKGxldCBbYXN0IChhcHBseSB3cml0ZSogbm9kZXMpXG5cbiAgICAgICAgb3V0cHV0IChnZW5lcmF0ZSogYXN0IHs6ZmlsZSAoOm91dHB1dC11cmkgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6c291cmNlQ29udGVudCAoOnNvdXJjZSBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzb3VyY2VNYXAgKDpzb3VyY2UtdXJpIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnNvdXJjZU1hcFJvb3QgKDpzb3VyY2Utcm9vdCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzb3VyY2VNYXBXaXRoQ29kZSB0cnVlfSldXG5cbiAgICA7OyBXb3JrYXJvdW5kIHRoZSBmYWN0IHRoYXQgZXNjb2RlZ2VuIGRvZXMgbm90IHlldCBpbmNsdWRlcyBzb3VyY2VcbiAgICAoLnNldFNvdXJjZUNvbnRlbnQgKDptYXAgb3V0cHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAoOnNvdXJjZS11cmkgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgKDpzb3VyY2Ugb3B0aW9ucykpXG5cbiAgICB7OmNvZGUgKGlmICg6bm8tbWFwIG9wdGlvbnMpXG4gICAgICAgICAgICAgKDpjb2RlIG91dHB1dClcbiAgICAgICAgICAgICAoc3RyICg6Y29kZSBvdXRwdXQpXG4gICAgICAgICAgICAgICAgICBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiXG4gICAgICAgICAgICAgICAgICBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCJcbiAgICAgICAgICAgICAgICAgIChidG9hIChzdHIgKDptYXAgb3V0cHV0KSkpXG4gICAgICAgICAgICAgICAgICBcIlxcblwiKSlcbiAgICAgOnNvdXJjZS1tYXAgKDptYXAgb3V0cHV0KVxuICAgICA6anMtYXN0IGFzdH0pKVxuXG5cbihkZWZuIGV4cGFuZC1kZWZtYWNyb1xuICBcIkxpa2UgZGVmbiwgYnV0IHRoZSByZXN1bHRpbmcgZnVuY3Rpb24gbmFtZSBpcyBkZWNsYXJlZCBhcyBhXG4gIG1hY3JvIGFuZCB3aWxsIGJlIHVzZWQgYXMgYSBtYWNybyBieSB0aGUgY29tcGlsZXIgd2hlbiBpdCBpc1xuICBjYWxsZWQuXCJcbiAgWyZmb3JtIGlkICYgYm9keV1cbiAgKGxldCBbZm4gKHdpdGgtbWV0YSBgKGRlZm4gfmlkIH5AYm9keSkgKG1ldGEgJmZvcm0pKVxuICAgICAgICBmb3JtIGAoZG8gfmZuIH5pZClcbiAgICAgICAgYXN0IChhbmFseXplIGZvcm0pXG4gICAgICAgIGNvZGUgKGNvbXBpbGUgYXN0KVxuICAgICAgICBtYWNybyAoZXZhbCBjb2RlKV1cbiAgICAoaW5zdGFsbC1tYWNybyEgaWQgbWFjcm8pXG4gICAgbmlsKSlcbihpbnN0YWxsLW1hY3JvISAnZGVmbWFjcm8gKHdpdGgtbWV0YSBleHBhbmQtZGVmbWFjcm8gezppbXBsaWNpdCBbOiZmb3JtXX0pKVxuIl19
